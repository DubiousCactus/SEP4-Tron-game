
FreeRTOS-Test.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000002e  00800100  00001b8c  00001c20  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00001b8c  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000004bc  0080012e  0080012e  00001c4e  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00001c4e  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00001c80  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000478  00000000  00000000  00001cc0  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000059a9  00000000  00000000  00002138  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000171e  00000000  00000000  00007ae1  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000030ca  00000000  00000000  000091ff  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000ee4  00000000  00000000  0000c2cc  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00001ca1  00000000  00000000  0000d1b0  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000592b  00000000  00000000  0000ee51  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000550  00000000  00000000  0001477c  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__ctors_end>
       4:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
       8:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
       c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      10:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      14:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      18:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      1c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      20:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      24:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      28:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      2c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      30:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      34:	0c 94 f0 03 	jmp	0x7e0	; 0x7e0 <__vector_13>
      38:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      3c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      40:	0c 94 3d 01 	jmp	0x27a	; 0x27a <__vector_16>
      44:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      48:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      4c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      50:	0c 94 e6 04 	jmp	0x9cc	; 0x9cc <__vector_20>
      54:	0c 94 24 05 	jmp	0xa48	; 0xa48 <__vector_21>
      58:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      5c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      60:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      64:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      68:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      6c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
      70:	0c 94 6c 05 	jmp	0xad8	; 0xad8 <__vector_28>
      74:	0c 94 aa 05 	jmp	0xb54	; 0xb54 <__vector_29>
      78:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>

0000007c <__ctors_end>:
      7c:	11 24       	eor	r1, r1
      7e:	1f be       	out	0x3f, r1	; 63
      80:	cf ef       	ldi	r28, 0xFF	; 255
      82:	d8 e0       	ldi	r29, 0x08	; 8
      84:	de bf       	out	0x3e, r29	; 62
      86:	cd bf       	out	0x3d, r28	; 61

00000088 <__do_copy_data>:
      88:	11 e0       	ldi	r17, 0x01	; 1
      8a:	a0 e0       	ldi	r26, 0x00	; 0
      8c:	b1 e0       	ldi	r27, 0x01	; 1
      8e:	ec e8       	ldi	r30, 0x8C	; 140
      90:	fb e1       	ldi	r31, 0x1B	; 27
      92:	02 c0       	rjmp	.+4      	; 0x98 <__do_copy_data+0x10>
      94:	05 90       	lpm	r0, Z+
      96:	0d 92       	st	X+, r0
      98:	ae 32       	cpi	r26, 0x2E	; 46
      9a:	b1 07       	cpc	r27, r17
      9c:	d9 f7       	brne	.-10     	; 0x94 <__do_copy_data+0xc>

0000009e <__do_clear_bss>:
      9e:	25 e0       	ldi	r18, 0x05	; 5
      a0:	ae e2       	ldi	r26, 0x2E	; 46
      a2:	b1 e0       	ldi	r27, 0x01	; 1
      a4:	01 c0       	rjmp	.+2      	; 0xa8 <.do_clear_bss_start>

000000a6 <.do_clear_bss_loop>:
      a6:	1d 92       	st	X+, r1

000000a8 <.do_clear_bss_start>:
      a8:	aa 3e       	cpi	r26, 0xEA	; 234
      aa:	b2 07       	cpc	r27, r18
      ac:	e1 f7       	brne	.-8      	; 0xa6 <.do_clear_bss_loop>
      ae:	0e 94 e4 00 	call	0x1c8	; 0x1c8 <main>
      b2:	0c 94 c4 0d 	jmp	0x1b88	; 0x1b88 <_exit>

000000b6 <__bad_interrupt>:
      b6:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000ba <read_joystick>:
		case RIGHT:
		if (player.direction == UP || player.direction == DOWN)
		player.direction = direction;
		break;
	}
}
      ba:	60 e0       	ldi	r22, 0x00	; 0
      bc:	50 e0       	ldi	r21, 0x00	; 0
      be:	c0 e0       	ldi	r28, 0x00	; 0
      c0:	10 e0       	ldi	r17, 0x00	; 0
      c2:	d1 e0       	ldi	r29, 0x01	; 1
      c4:	13 c0       	rjmp	.+38     	; 0xec <read_joystick+0x32>
      c6:	c0 e0       	ldi	r28, 0x00	; 0
      c8:	6d 2f       	mov	r22, r29
      ca:	5d 2f       	mov	r21, r29
      cc:	0f c0       	rjmp	.+30     	; 0xec <read_joystick+0x32>
      ce:	c0 e0       	ldi	r28, 0x00	; 0
      d0:	6d 2f       	mov	r22, r29
      d2:	5d 2f       	mov	r21, r29
      d4:	0b c0       	rjmp	.+22     	; 0xec <read_joystick+0x32>
      d6:	c0 e0       	ldi	r28, 0x00	; 0
      d8:	6d 2f       	mov	r22, r29
      da:	5d 2f       	mov	r21, r29
      dc:	07 c0       	rjmp	.+14     	; 0xec <read_joystick+0x32>
      de:	c0 e0       	ldi	r28, 0x00	; 0
      e0:	6d 2f       	mov	r22, r29
      e2:	5d 2f       	mov	r21, r29
      e4:	03 c0       	rjmp	.+6      	; 0xec <read_joystick+0x32>
      e6:	c0 e0       	ldi	r28, 0x00	; 0
      e8:	01 c0       	rjmp	.+2      	; 0xec <read_joystick+0x32>
      ea:	c0 e0       	ldi	r28, 0x00	; 0
      ec:	86 b1       	in	r24, 0x06	; 6
      ee:	82 70       	andi	r24, 0x02	; 2
      f0:	36 b1       	in	r19, 0x06	; 6
      f2:	26 b1       	in	r18, 0x06	; 6
      f4:	96 b1       	in	r25, 0x06	; 6
      f6:	49 b1       	in	r20, 0x09	; 9
      f8:	90 fd       	sbrc	r25, 0
      fa:	03 c0       	rjmp	.+6      	; 0x102 <read_joystick+0x48>
      fc:	cf 30       	cpi	r28, 0x0F	; 15
      fe:	18 f7       	brcc	.-58     	; 0xc6 <read_joystick+0xc>
     100:	cf 5f       	subi	r28, 0xFF	; 255
     102:	81 11       	cpse	r24, r1
     104:	03 c0       	rjmp	.+6      	; 0x10c <read_joystick+0x52>
     106:	cf 30       	cpi	r28, 0x0F	; 15
     108:	10 f7       	brcc	.-60     	; 0xce <read_joystick+0x14>
     10a:	cf 5f       	subi	r28, 0xFF	; 255
     10c:	26 fd       	sbrc	r18, 6
     10e:	03 c0       	rjmp	.+6      	; 0x116 <read_joystick+0x5c>
     110:	cf 30       	cpi	r28, 0x0F	; 15
     112:	08 f7       	brcc	.-62     	; 0xd6 <read_joystick+0x1c>
     114:	cf 5f       	subi	r28, 0xFF	; 255
     116:	33 23       	and	r19, r19
     118:	1c f0       	brlt	.+6      	; 0x120 <read_joystick+0x66>
     11a:	cf 30       	cpi	r28, 0x0F	; 15
     11c:	00 f7       	brcc	.-64     	; 0xde <read_joystick+0x24>
     11e:	cf 5f       	subi	r28, 0xFF	; 255
     120:	43 fd       	sbrc	r20, 3
     122:	11 c0       	rjmp	.+34     	; 0x146 <read_joystick+0x8c>
     124:	cf 30       	cpi	r28, 0x0F	; 15
     126:	10 f4       	brcc	.+4      	; 0x12c <read_joystick+0x72>
     128:	cf 5f       	subi	r28, 0xFF	; 255
     12a:	0d c0       	rjmp	.+26     	; 0x146 <read_joystick+0x8c>
     12c:	55 23       	and	r21, r21
     12e:	d9 f2       	breq	.-74     	; 0xe6 <read_joystick+0x2c>
     130:	61 11       	cpse	r22, r1
     132:	db cf       	rjmp	.-74     	; 0xea <read_joystick+0x30>
     134:	c0 e0       	ldi	r28, 0x00	; 0
     136:	64 e0       	ldi	r22, 0x04	; 4
     138:	8a e0       	ldi	r24, 0x0A	; 10
     13a:	91 e0       	ldi	r25, 0x01	; 1
     13c:	0e 94 66 01 	call	0x2cc	; 0x2cc <com_send_bytes>
     140:	61 2f       	mov	r22, r17
     142:	51 2f       	mov	r21, r17
     144:	d3 cf       	rjmp	.-90     	; 0xec <read_joystick+0x32>
     146:	51 11       	cpse	r21, r1
     148:	f6 cf       	rjmp	.-20     	; 0x136 <read_joystick+0x7c>
     14a:	61 2f       	mov	r22, r17
     14c:	cf cf       	rjmp	.-98     	; 0xec <read_joystick+0x32>

0000014e <prepare_shiftregister>:

// Prepare shift register setting SER = 1
void prepare_shiftregister()
{
	// Set SER to 1
	PORTD |= _BV(PORTD2);
     14e:	5a 9a       	sbi	0x0b, 2	; 11
     150:	08 95       	ret

00000152 <clock_shift_register_and_prepare_for_next_col>:

// clock shift-register
void clock_shift_register_and_prepare_for_next_col()
{
	// one SCK pulse
	PORTD |= _BV(PORTD5);
     152:	5d 9a       	sbi	0x0b, 5	; 11
	PORTD &= ~_BV(PORTD5);
     154:	5d 98       	cbi	0x0b, 5	; 11
	
	// one RCK pulse
	PORTD |= _BV(PORTD4);
     156:	5c 9a       	sbi	0x0b, 4	; 11
	PORTD &= ~_BV(PORTD4);
     158:	5c 98       	cbi	0x0b, 4	; 11
	
	// Set SER to 0 - for next column
	PORTD &= ~_BV(PORTD2);
     15a:	5a 98       	cbi	0x0b, 2	; 11
     15c:	08 95       	ret

0000015e <load_col_value>:
}

// Load column value for column to show
void load_col_value(uint16_t col_value)
{
	PORTA = ~(col_value & 0xFF);
     15e:	80 95       	com	r24
     160:	82 b9       	out	0x02, r24	; 2
	
	// Manipulate only with PB0 and PB1
	PORTB |= 0x03;
     162:	85 b1       	in	r24, 0x05	; 5
     164:	83 60       	ori	r24, 0x03	; 3
     166:	85 b9       	out	0x05, r24	; 5
	PORTB &= ~((col_value >> 8) & 0x03);
     168:	85 b1       	in	r24, 0x05	; 5
     16a:	93 70       	andi	r25, 0x03	; 3
     16c:	90 95       	com	r25
     16e:	89 23       	and	r24, r25
     170:	85 b9       	out	0x05, r24	; 5
     172:	08 95       	ret

00000174 <handle_display>:
}

//-----------------------------------------
void handle_display(void)
{
     174:	cf 93       	push	r28
	static uint8_t col = 0;
	
	if (col == 0)
     176:	c0 91 2e 01 	lds	r28, 0x012E	; 0x80012e <__data_end>
     17a:	c1 11       	cpse	r28, r1
     17c:	0e c0       	rjmp	.+28     	; 0x19a <handle_display+0x26>
	prepare_shiftregister();
     17e:	0e 94 a7 00 	call	0x14e	; 0x14e <prepare_shiftregister>
	
	load_col_value(frame_buffer[col]);
     182:	80 91 31 01 	lds	r24, 0x0131	; 0x800131 <frame_buffer>
     186:	90 91 32 01 	lds	r25, 0x0132	; 0x800132 <frame_buffer+0x1>
     18a:	0e 94 af 00 	call	0x15e	; 0x15e <load_col_value>
	
	clock_shift_register_and_prepare_for_next_col();
     18e:	0e 94 a9 00 	call	0x152	; 0x152 <clock_shift_register_and_prepare_for_next_col>
	
	// count column up - prepare for next
	if (col++ > 13)
     192:	81 e0       	ldi	r24, 0x01	; 1
     194:	80 93 2e 01 	sts	0x012E, r24	; 0x80012e <__data_end>
     198:	14 c0       	rjmp	.+40     	; 0x1c2 <handle_display+0x4e>
	static uint8_t col = 0;
	
	if (col == 0)
	prepare_shiftregister();
	
	load_col_value(frame_buffer[col]);
     19a:	ec 2f       	mov	r30, r28
     19c:	f0 e0       	ldi	r31, 0x00	; 0
     19e:	ee 0f       	add	r30, r30
     1a0:	ff 1f       	adc	r31, r31
     1a2:	ef 5c       	subi	r30, 0xCF	; 207
     1a4:	fe 4f       	sbci	r31, 0xFE	; 254
     1a6:	80 81       	ld	r24, Z
     1a8:	91 81       	ldd	r25, Z+1	; 0x01
     1aa:	0e 94 af 00 	call	0x15e	; 0x15e <load_col_value>
	
	clock_shift_register_and_prepare_for_next_col();
     1ae:	0e 94 a9 00 	call	0x152	; 0x152 <clock_shift_register_and_prepare_for_next_col>
	
	// count column up - prepare for next
	if (col++ > 13)
     1b2:	ce 30       	cpi	r28, 0x0E	; 14
     1b4:	20 f4       	brcc	.+8      	; 0x1be <handle_display+0x4a>
     1b6:	cf 5f       	subi	r28, 0xFF	; 255
     1b8:	c0 93 2e 01 	sts	0x012E, r28	; 0x80012e <__data_end>
     1bc:	02 c0       	rjmp	.+4      	; 0x1c2 <handle_display+0x4e>
	col = 0;
     1be:	10 92 2e 01 	sts	0x012E, r1	; 0x80012e <__data_end>
}
     1c2:	cf 91       	pop	r28
     1c4:	08 95       	ret

000001c6 <vApplicationIdleHook>:

//-----------------------------------------
void vApplicationIdleHook( void )
{
     1c6:	08 95       	ret

000001c8 <main>:

//-----------------------------------------
int main(void)
{
	
	init_board();
     1c8:	0e 94 6f 01 	call	0x2de	; 0x2de <init_board>
	
	// Shift register Enable output (G=0)
	PORTD &= ~_BV(PORTD6);
     1cc:	5e 98       	cbi	0x0b, 6	; 11

	/* Semaphores creation */
	xGameStateSemaphore = xSemaphoreCreateMutex();
     1ce:	81 e0       	ldi	r24, 0x01	; 1
     1d0:	0e 94 ad 07 	call	0xf5a	; 0xf5a <xQueueCreateMutex>
	xPlayerOneSemaphore = xSemaphoreCreateMutex();
     1d4:	81 e0       	ldi	r24, 0x01	; 1
     1d6:	0e 94 ad 07 	call	0xf5a	; 0xf5a <xQueueCreateMutex>
	xPlayerTwoSemaphore = xSemaphoreCreateMutex();
     1da:	81 e0       	ldi	r24, 0x01	; 1
     1dc:	0e 94 ad 07 	call	0xf5a	; 0xf5a <xQueueCreateMutex>
	xGameOverSemaphore = xSemaphoreCreateMutex();
     1e0:	81 e0       	ldi	r24, 0x01	; 1
     1e2:	0e 94 ad 07 	call	0xf5a	; 0xf5a <xQueueCreateMutex>
     1e6:	90 93 30 01 	sts	0x0130, r25	; 0x800130 <xGameOverSemaphore+0x1>
     1ea:	80 93 2f 01 	sts	0x012F, r24	; 0x80012f <xGameOverSemaphore>

	BaseType_t taskReadJoystick = xTaskCreate(read_joystick, (const char*)"Read joystick", configMINIMAL_STACK_SIZE, (void *)NULL, tskIDLE_PRIORITY, NULL);
     1ee:	e1 2c       	mov	r14, r1
     1f0:	f1 2c       	mov	r15, r1
     1f2:	00 e0       	ldi	r16, 0x00	; 0
     1f4:	20 e0       	ldi	r18, 0x00	; 0
     1f6:	30 e0       	ldi	r19, 0x00	; 0
     1f8:	45 e5       	ldi	r20, 0x55	; 85
     1fa:	50 e0       	ldi	r21, 0x00	; 0
     1fc:	6a e1       	ldi	r22, 0x1A	; 26
     1fe:	71 e0       	ldi	r23, 0x01	; 1
     200:	8d e5       	ldi	r24, 0x5D	; 93
     202:	90 e0       	ldi	r25, 0x00	; 0
     204:	0e 94 64 08 	call	0x10c8	; 0x10c8 <xTaskCreate>


	// Start the display handler timer
	init_display_timer(handle_display);
     208:	8a eb       	ldi	r24, 0xBA	; 186
     20a:	90 e0       	ldi	r25, 0x00	; 0
     20c:	0e 94 2b 01 	call	0x256	; 0x256 <init_display_timer>
	
	sei();
     210:	78 94       	sei
	
	//Start the scheduler
	vTaskStartScheduler();
     212:	0e 94 79 09 	call	0x12f2	; 0x12f2 <vTaskStartScheduler>
     216:	ff cf       	rjmp	.-2      	; 0x216 <main+0x4e>

00000218 <_com_call_back>:
	}
}

// ----------------------------------------------------------------------------------------------------------------------
void init_com(QueueHandle_t x_rx_queue) {
	_x_rx_com_queue = x_rx_queue;
     218:	cf 93       	push	r28
     21a:	df 93       	push	r29
     21c:	00 d0       	rcall	.+0      	; 0x21e <_com_call_back+0x6>
     21e:	cd b7       	in	r28, 0x3d	; 61
     220:	de b7       	in	r29, 0x3e	; 62
     222:	6a 83       	std	Y+2, r22	; 0x02
     224:	80 91 95 01 	lds	r24, 0x0195	; 0x800195 <_x_rx_com_queue>
     228:	90 91 96 01 	lds	r25, 0x0196	; 0x800196 <_x_rx_com_queue+0x1>
     22c:	00 97       	sbiw	r24, 0x00	; 0
     22e:	71 f0       	breq	.+28     	; 0x24c <_com_call_back+0x34>
     230:	19 82       	std	Y+1, r1	; 0x01
     232:	20 e0       	ldi	r18, 0x00	; 0
     234:	ae 01       	movw	r20, r28
     236:	4f 5f       	subi	r20, 0xFF	; 255
     238:	5f 4f       	sbci	r21, 0xFF	; 255
     23a:	be 01       	movw	r22, r28
     23c:	6e 5f       	subi	r22, 0xFE	; 254
     23e:	7f 4f       	sbci	r23, 0xFF	; 255
     240:	0e 94 c7 07 	call	0xf8e	; 0xf8e <xQueueGenericSendFromISR>
     244:	89 81       	ldd	r24, Y+1	; 0x01
     246:	81 11       	cpse	r24, r1
     248:	0e 94 3b 03 	call	0x676	; 0x676 <vPortYield>
     24c:	0f 90       	pop	r0
     24e:	0f 90       	pop	r0
     250:	df 91       	pop	r29
     252:	cf 91       	pop	r28
     254:	08 95       	ret

00000256 <init_display_timer>:
}

// ----------------------------------------------------------------------------------------------------------------------
void init_display_timer(display_callback_ptr_t cb)
{
	cb_ptr = cb;
     256:	90 93 94 01 	sts	0x0194, r25	; 0x800194 <cb_ptr+0x1>
     25a:	80 93 93 01 	sts	0x0193, r24	; 0x800193 <cb_ptr>
	
	// Setup timer T0 to CTC, ~1309 Hz
	OCR0A = 10;
     25e:	8a e0       	ldi	r24, 0x0A	; 10
     260:	87 bd       	out	0x27, r24	; 39
	TCCR0A |= _BV(WGM01); // Mode 2
     262:	84 b5       	in	r24, 0x24	; 36
     264:	82 60       	ori	r24, 0x02	; 2
     266:	84 bd       	out	0x24, r24	; 36
	TIMSK0 |= _BV(OCIE0A); // Enable interrupt
     268:	ee e6       	ldi	r30, 0x6E	; 110
     26a:	f0 e0       	ldi	r31, 0x00	; 0
     26c:	80 81       	ld	r24, Z
     26e:	82 60       	ori	r24, 0x02	; 2
     270:	80 83       	st	Z, r24
	TCCR0B |= _BV(CS00) | _BV(CS02); // Prescaler 1024 - and start timer
     272:	85 b5       	in	r24, 0x25	; 37
     274:	85 60       	ori	r24, 0x05	; 5
     276:	85 bd       	out	0x25, r24	; 37
     278:	08 95       	ret

0000027a <__vector_16>:
}

// ----------------------------------------------------------------------------------------------------------------------
//ISR for display timer
ISR(TIMER0_COMPA_vect)
{
     27a:	1f 92       	push	r1
     27c:	0f 92       	push	r0
     27e:	0f b6       	in	r0, 0x3f	; 63
     280:	0f 92       	push	r0
     282:	11 24       	eor	r1, r1
     284:	2f 93       	push	r18
     286:	3f 93       	push	r19
     288:	4f 93       	push	r20
     28a:	5f 93       	push	r21
     28c:	6f 93       	push	r22
     28e:	7f 93       	push	r23
     290:	8f 93       	push	r24
     292:	9f 93       	push	r25
     294:	af 93       	push	r26
     296:	bf 93       	push	r27
     298:	ef 93       	push	r30
     29a:	ff 93       	push	r31
	if (cb_ptr)
     29c:	e0 91 93 01 	lds	r30, 0x0193	; 0x800193 <cb_ptr>
     2a0:	f0 91 94 01 	lds	r31, 0x0194	; 0x800194 <cb_ptr+0x1>
     2a4:	30 97       	sbiw	r30, 0x00	; 0
     2a6:	09 f0       	breq	.+2      	; 0x2aa <__vector_16+0x30>
	{
		cb_ptr();
     2a8:	09 95       	icall
	}
}
     2aa:	ff 91       	pop	r31
     2ac:	ef 91       	pop	r30
     2ae:	bf 91       	pop	r27
     2b0:	af 91       	pop	r26
     2b2:	9f 91       	pop	r25
     2b4:	8f 91       	pop	r24
     2b6:	7f 91       	pop	r23
     2b8:	6f 91       	pop	r22
     2ba:	5f 91       	pop	r21
     2bc:	4f 91       	pop	r20
     2be:	3f 91       	pop	r19
     2c0:	2f 91       	pop	r18
     2c2:	0f 90       	pop	r0
     2c4:	0f be       	out	0x3f, r0	; 63
     2c6:	0f 90       	pop	r0
     2c8:	1f 90       	pop	r1
     2ca:	18 95       	reti

000002cc <com_send_bytes>:

// ----------------------------------------------------------------------------------------------------------------------
void com_send_bytes(uint8_t *bytes, uint8_t len) {
     2cc:	46 2f       	mov	r20, r22
	serial_send_bytes(_com_serial_instance, bytes, len);
     2ce:	bc 01       	movw	r22, r24
     2d0:	80 91 97 01 	lds	r24, 0x0197	; 0x800197 <_com_serial_instance>
     2d4:	90 91 98 01 	lds	r25, 0x0198	; 0x800198 <_com_serial_instance+0x1>
     2d8:	0e 94 a3 04 	call	0x946	; 0x946 <serial_send_bytes>
     2dc:	08 95       	ret

000002de <init_board>:
}

// ----------------------------------------------------------------------------------------------------------------------
void init_board(void) {
     2de:	8f 92       	push	r8
     2e0:	9f 92       	push	r9
     2e2:	af 92       	push	r10
     2e4:	bf 92       	push	r11
     2e6:	cf 92       	push	r12
     2e8:	df 92       	push	r13
     2ea:	ef 92       	push	r14
     2ec:	0f 93       	push	r16
	static buffer_struct_t _com_rx_buffer;
	static buffer_struct_t _com_tx_buffer;
	buffer_init(&_com_rx_buffer);
     2ee:	80 e7       	ldi	r24, 0x70	; 112
     2f0:	91 e0       	ldi	r25, 0x01	; 1
     2f2:	0e 94 c8 01 	call	0x390	; 0x390 <buffer_init>
	buffer_init(&_com_tx_buffer);
     2f6:	8d e4       	ldi	r24, 0x4D	; 77
     2f8:	91 e0       	ldi	r25, 0x01	; 1
     2fa:	0e 94 c8 01 	call	0x390	; 0x390 <buffer_init>
	_com_serial_instance = serial_new_instance(ser_USART0, 115200UL, ser_BITS_8, ser_STOP_1, ser_NO_PARITY, &_com_rx_buffer, &_com_tx_buffer, _com_call_back);
     2fe:	0f 2e       	mov	r0, r31
     300:	fc e0       	ldi	r31, 0x0C	; 12
     302:	8f 2e       	mov	r8, r31
     304:	f1 e0       	ldi	r31, 0x01	; 1
     306:	9f 2e       	mov	r9, r31
     308:	f0 2d       	mov	r31, r0
     30a:	0f 2e       	mov	r0, r31
     30c:	fd e4       	ldi	r31, 0x4D	; 77
     30e:	af 2e       	mov	r10, r31
     310:	f1 e0       	ldi	r31, 0x01	; 1
     312:	bf 2e       	mov	r11, r31
     314:	f0 2d       	mov	r31, r0
     316:	0f 2e       	mov	r0, r31
     318:	f0 e7       	ldi	r31, 0x70	; 112
     31a:	cf 2e       	mov	r12, r31
     31c:	f1 e0       	ldi	r31, 0x01	; 1
     31e:	df 2e       	mov	r13, r31
     320:	f0 2d       	mov	r31, r0
     322:	e1 2c       	mov	r14, r1
     324:	00 e0       	ldi	r16, 0x00	; 0
     326:	23 e0       	ldi	r18, 0x03	; 3
     328:	40 e0       	ldi	r20, 0x00	; 0
     32a:	52 ec       	ldi	r21, 0xC2	; 194
     32c:	61 e0       	ldi	r22, 0x01	; 1
     32e:	70 e0       	ldi	r23, 0x00	; 0
     330:	80 e0       	ldi	r24, 0x00	; 0
     332:	0e 94 29 04 	call	0x852	; 0x852 <serial_new_instance>
     336:	90 93 98 01 	sts	0x0198, r25	; 0x800198 <_com_serial_instance+0x1>
     33a:	80 93 97 01 	sts	0x0197, r24	; 0x800197 <_com_serial_instance>
	
	// Pull up on Joystick inputs
	PORTC |= _BV(PORTC0) | _BV(PORTC1) | _BV(PORTC6) | _BV(PORTC7);
     33e:	88 b1       	in	r24, 0x08	; 8
     340:	83 6c       	ori	r24, 0xC3	; 195
     342:	88 b9       	out	0x08, r24	; 8
	PORTD |= _BV(PORTD3);
     344:	5b 9a       	sbi	0x0b, 3	; 11
	
	// Shift register control pins to output
	// SER, RCK, SCK, G (enable output)
	DDRD |= _BV(DDD2) | _BV(DDD4) | _BV(DDD5) | _BV(DDD6);
     346:	8a b1       	in	r24, 0x0a	; 10
     348:	84 67       	ori	r24, 0x74	; 116
     34a:	8a b9       	out	0x0a, r24	; 10
	// G (enable output) high
	PORTD |= _BV(PORTD6);
     34c:	5e 9a       	sbi	0x0b, 6	; 11
	
	// Column pins to output
	DDRA |= 0xFF;
     34e:	81 b1       	in	r24, 0x01	; 1
     350:	8f ef       	ldi	r24, 0xFF	; 255
     352:	81 b9       	out	0x01, r24	; 1
	DDRB |= _BV(DDB0) | _BV(DDB1);
     354:	84 b1       	in	r24, 0x04	; 4
     356:	83 60       	ori	r24, 0x03	; 3
     358:	84 b9       	out	0x04, r24	; 4
	
	// Trace pins Task Monitor (R2R)
	DDRB |= _BV(DDB2) | _BV(DDB3) | _BV(DDB4) | _BV(DDB5);
     35a:	84 b1       	in	r24, 0x04	; 4
     35c:	8c 63       	ori	r24, 0x3C	; 60
     35e:	84 b9       	out	0x04, r24	; 4
}
     360:	0f 91       	pop	r16
     362:	ef 90       	pop	r14
     364:	df 90       	pop	r13
     366:	cf 90       	pop	r12
     368:	bf 90       	pop	r11
     36a:	af 90       	pop	r10
     36c:	9f 90       	pop	r9
     36e:	8f 90       	pop	r8
     370:	08 95       	ret

00000372 <switch_in>:
	
	 Called by the the traceTASK_SWITCHED_IN() macro in FreeRTOS.
	 Are enabled in FreeRTOSConfig.h
	 **********************************************************************/
	void switch_in(uint8_t task_no) {
		PORTB &= 0b11000011;
     372:	95 b1       	in	r25, 0x05	; 5
     374:	93 7c       	andi	r25, 0xC3	; 195
     376:	95 b9       	out	0x05, r25	; 5
		PORTB |= task_no << 2;
     378:	25 b1       	in	r18, 0x05	; 5
     37a:	34 e0       	ldi	r19, 0x04	; 4
     37c:	83 9f       	mul	r24, r19
     37e:	c0 01       	movw	r24, r0
     380:	11 24       	eor	r1, r1
     382:	82 2b       	or	r24, r18
     384:	85 b9       	out	0x05, r24	; 5
     386:	08 95       	ret

00000388 <switch_out>:
	
	 Called by the the traceTASK_SWITCHED_OUT() macro in FreeRTOS.
	 Are enabled in FreeRTOSConfig.h
	 **********************************************************************/
	void switch_out(uint8_t task_no) {
		PORTB &= 0b11000011;
     388:	85 b1       	in	r24, 0x05	; 5
     38a:	83 7c       	andi	r24, 0xC3	; 195
     38c:	85 b9       	out	0x05, r24	; 5
     38e:	08 95       	ret

00000390 <buffer_init>:
  @endcode

 @note The buffer structure must be initialized before any of the buffer functions must be called.
 @param *buffer Pointer to the buffer structure to be used.
 ***********************************************/
void buffer_init(buffer_struct_t *buffer) {
     390:	fc 01       	movw	r30, r24
	buffer->in_i = 0;
     392:	10 a2       	std	Z+32, r1	; 0x20
	buffer->out_i = 0;
     394:	11 a2       	std	Z+33, r1	; 0x21
	buffer->no_in_buffer = 0;
     396:	12 a2       	std	Z+34, r1	; 0x22
     398:	08 95       	ret

0000039a <buffer_get_item>:
 @return BUFFER_OK: item removed from buffer and returned in item.\n
    BUFFER_EMPTY: The buffer is empty, item is not updated.
 @param *buffer pointer to the buffer structure.
 @param *item pointer to the variable where the value of the item is returned.
 ***********************************************/
uint8_t buffer_get_item(buffer_struct_t *buffer, uint8_t *item) {
     39a:	fc 01       	movw	r30, r24
	if (buffer->no_in_buffer > 0) {
     39c:	82 a1       	ldd	r24, Z+34	; 0x22
     39e:	88 23       	and	r24, r24
     3a0:	d9 f0       	breq	.+54     	; 0x3d8 <buffer_get_item+0x3e>
		*item = buffer->storage[buffer->out_i];
     3a2:	81 a1       	ldd	r24, Z+33	; 0x21
     3a4:	df 01       	movw	r26, r30
     3a6:	a8 0f       	add	r26, r24
     3a8:	b1 1d       	adc	r27, r1
     3aa:	8c 91       	ld	r24, X
     3ac:	db 01       	movw	r26, r22
     3ae:	8c 93       	st	X, r24
		buffer->out_i = INCREMENT(buffer->out_i);
     3b0:	21 a1       	ldd	r18, Z+33	; 0x21
     3b2:	30 e0       	ldi	r19, 0x00	; 0
     3b4:	2f 5f       	subi	r18, 0xFF	; 255
     3b6:	3f 4f       	sbci	r19, 0xFF	; 255
     3b8:	2f 71       	andi	r18, 0x1F	; 31
     3ba:	30 78       	andi	r19, 0x80	; 128
     3bc:	33 23       	and	r19, r19
     3be:	34 f4       	brge	.+12     	; 0x3cc <buffer_get_item+0x32>
     3c0:	21 50       	subi	r18, 0x01	; 1
     3c2:	31 09       	sbc	r19, r1
     3c4:	20 6e       	ori	r18, 0xE0	; 224
     3c6:	3f 6f       	ori	r19, 0xFF	; 255
     3c8:	2f 5f       	subi	r18, 0xFF	; 255
     3ca:	3f 4f       	sbci	r19, 0xFF	; 255
     3cc:	21 a3       	std	Z+33, r18	; 0x21
		buffer->no_in_buffer--;
     3ce:	82 a1       	ldd	r24, Z+34	; 0x22
     3d0:	81 50       	subi	r24, 0x01	; 1
     3d2:	82 a3       	std	Z+34, r24	; 0x22
		return BUFFER_OK;
     3d4:	80 e0       	ldi	r24, 0x00	; 0
     3d6:	08 95       	ret
	}
	return BUFFER_EMPTY;
     3d8:	81 e0       	ldi	r24, 0x01	; 1
}
     3da:	08 95       	ret

000003dc <buffer_put_item>:
    BUFFER_FULL: The buffer is full, item is not stored.
 @param *buffer pointer to the buffer structure.
 @param item to be stored in the buffer.
 ***********************************************/
uint8_t buffer_put_item(buffer_struct_t *buffer, uint8_t item) {
	if (buffer->no_in_buffer<BUFFER_SIZE) {
     3dc:	fc 01       	movw	r30, r24
     3de:	42 a1       	ldd	r20, Z+34	; 0x22
     3e0:	40 32       	cpi	r20, 0x20	; 32
     3e2:	b8 f4       	brcc	.+46     	; 0x412 <__LOCK_REGION_LENGTH__+0x12>
		buffer->storage[buffer->in_i] = item;
     3e4:	20 a1       	ldd	r18, Z+32	; 0x20
     3e6:	30 e0       	ldi	r19, 0x00	; 0
     3e8:	e2 0f       	add	r30, r18
     3ea:	f3 1f       	adc	r31, r19
     3ec:	60 83       	st	Z, r22
		buffer->in_i = INCREMENT(buffer->in_i);
     3ee:	2f 5f       	subi	r18, 0xFF	; 255
     3f0:	3f 4f       	sbci	r19, 0xFF	; 255
     3f2:	2f 71       	andi	r18, 0x1F	; 31
     3f4:	30 78       	andi	r19, 0x80	; 128
     3f6:	33 23       	and	r19, r19
     3f8:	34 f4       	brge	.+12     	; 0x406 <__LOCK_REGION_LENGTH__+0x6>
     3fa:	21 50       	subi	r18, 0x01	; 1
     3fc:	31 09       	sbc	r19, r1
     3fe:	20 6e       	ori	r18, 0xE0	; 224
     400:	3f 6f       	ori	r19, 0xFF	; 255
     402:	2f 5f       	subi	r18, 0xFF	; 255
     404:	3f 4f       	sbci	r19, 0xFF	; 255
     406:	fc 01       	movw	r30, r24
     408:	20 a3       	std	Z+32, r18	; 0x20
		buffer->no_in_buffer++;
     40a:	4f 5f       	subi	r20, 0xFF	; 255
     40c:	42 a3       	std	Z+34, r20	; 0x22
		return BUFFER_OK;
     40e:	80 e0       	ldi	r24, 0x00	; 0
     410:	08 95       	ret
	}
	return BUFFER_FULL;
     412:	82 e0       	ldi	r24, 0x02	; 2
}
     414:	08 95       	ret

00000416 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     416:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     418:	03 96       	adiw	r24, 0x03	; 3
     41a:	92 83       	std	Z+2, r25	; 0x02
     41c:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     41e:	2f ef       	ldi	r18, 0xFF	; 255
     420:	3f ef       	ldi	r19, 0xFF	; 255
     422:	34 83       	std	Z+4, r19	; 0x04
     424:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     426:	96 83       	std	Z+6, r25	; 0x06
     428:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     42a:	90 87       	std	Z+8, r25	; 0x08
     42c:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     42e:	10 82       	st	Z, r1
     430:	08 95       	ret

00000432 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     432:	fc 01       	movw	r30, r24
     434:	11 86       	std	Z+9, r1	; 0x09
     436:	10 86       	std	Z+8, r1	; 0x08
     438:	08 95       	ret

0000043a <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     43a:	cf 93       	push	r28
     43c:	df 93       	push	r29
     43e:	9c 01       	movw	r18, r24
     440:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     442:	dc 01       	movw	r26, r24
     444:	11 96       	adiw	r26, 0x01	; 1
     446:	cd 91       	ld	r28, X+
     448:	dc 91       	ld	r29, X
     44a:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     44c:	d3 83       	std	Z+3, r29	; 0x03
     44e:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     450:	8c 81       	ldd	r24, Y+4	; 0x04
     452:	9d 81       	ldd	r25, Y+5	; 0x05
     454:	95 83       	std	Z+5, r25	; 0x05
     456:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
     458:	8c 81       	ldd	r24, Y+4	; 0x04
     45a:	9d 81       	ldd	r25, Y+5	; 0x05
     45c:	dc 01       	movw	r26, r24
     45e:	13 96       	adiw	r26, 0x03	; 3
     460:	7c 93       	st	X, r23
     462:	6e 93       	st	-X, r22
     464:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     466:	7d 83       	std	Y+5, r23	; 0x05
     468:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     46a:	31 87       	std	Z+9, r19	; 0x09
     46c:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     46e:	f9 01       	movw	r30, r18
     470:	80 81       	ld	r24, Z
     472:	8f 5f       	subi	r24, 0xFF	; 255
     474:	80 83       	st	Z, r24
}
     476:	df 91       	pop	r29
     478:	cf 91       	pop	r28
     47a:	08 95       	ret

0000047c <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     47c:	cf 93       	push	r28
     47e:	df 93       	push	r29
     480:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     482:	48 81       	ld	r20, Y
     484:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     486:	4f 3f       	cpi	r20, 0xFF	; 255
     488:	2f ef       	ldi	r18, 0xFF	; 255
     48a:	52 07       	cpc	r21, r18
     48c:	21 f4       	brne	.+8      	; 0x496 <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     48e:	fc 01       	movw	r30, r24
     490:	a7 81       	ldd	r26, Z+7	; 0x07
     492:	b0 85       	ldd	r27, Z+8	; 0x08
     494:	0d c0       	rjmp	.+26     	; 0x4b0 <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     496:	dc 01       	movw	r26, r24
     498:	13 96       	adiw	r26, 0x03	; 3
     49a:	01 c0       	rjmp	.+2      	; 0x49e <vListInsert+0x22>
     49c:	df 01       	movw	r26, r30
     49e:	12 96       	adiw	r26, 0x02	; 2
     4a0:	ed 91       	ld	r30, X+
     4a2:	fc 91       	ld	r31, X
     4a4:	13 97       	sbiw	r26, 0x03	; 3
     4a6:	20 81       	ld	r18, Z
     4a8:	31 81       	ldd	r19, Z+1	; 0x01
     4aa:	42 17       	cp	r20, r18
     4ac:	53 07       	cpc	r21, r19
     4ae:	b0 f7       	brcc	.-20     	; 0x49c <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     4b0:	12 96       	adiw	r26, 0x02	; 2
     4b2:	ed 91       	ld	r30, X+
     4b4:	fc 91       	ld	r31, X
     4b6:	13 97       	sbiw	r26, 0x03	; 3
     4b8:	fb 83       	std	Y+3, r31	; 0x03
     4ba:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     4bc:	d5 83       	std	Z+5, r29	; 0x05
     4be:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     4c0:	bd 83       	std	Y+5, r27	; 0x05
     4c2:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     4c4:	13 96       	adiw	r26, 0x03	; 3
     4c6:	dc 93       	st	X, r29
     4c8:	ce 93       	st	-X, r28
     4ca:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     4cc:	99 87       	std	Y+9, r25	; 0x09
     4ce:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     4d0:	fc 01       	movw	r30, r24
     4d2:	20 81       	ld	r18, Z
     4d4:	2f 5f       	subi	r18, 0xFF	; 255
     4d6:	20 83       	st	Z, r18
}
     4d8:	df 91       	pop	r29
     4da:	cf 91       	pop	r28
     4dc:	08 95       	ret

000004de <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     4de:	cf 93       	push	r28
     4e0:	df 93       	push	r29
     4e2:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     4e4:	a0 85       	ldd	r26, Z+8	; 0x08
     4e6:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     4e8:	c2 81       	ldd	r28, Z+2	; 0x02
     4ea:	d3 81       	ldd	r29, Z+3	; 0x03
     4ec:	84 81       	ldd	r24, Z+4	; 0x04
     4ee:	95 81       	ldd	r25, Z+5	; 0x05
     4f0:	9d 83       	std	Y+5, r25	; 0x05
     4f2:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     4f4:	c4 81       	ldd	r28, Z+4	; 0x04
     4f6:	d5 81       	ldd	r29, Z+5	; 0x05
     4f8:	82 81       	ldd	r24, Z+2	; 0x02
     4fa:	93 81       	ldd	r25, Z+3	; 0x03
     4fc:	9b 83       	std	Y+3, r25	; 0x03
     4fe:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     500:	11 96       	adiw	r26, 0x01	; 1
     502:	8d 91       	ld	r24, X+
     504:	9c 91       	ld	r25, X
     506:	12 97       	sbiw	r26, 0x02	; 2
     508:	e8 17       	cp	r30, r24
     50a:	f9 07       	cpc	r31, r25
     50c:	31 f4       	brne	.+12     	; 0x51a <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     50e:	84 81       	ldd	r24, Z+4	; 0x04
     510:	95 81       	ldd	r25, Z+5	; 0x05
     512:	12 96       	adiw	r26, 0x02	; 2
     514:	9c 93       	st	X, r25
     516:	8e 93       	st	-X, r24
     518:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     51a:	11 86       	std	Z+9, r1	; 0x09
     51c:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     51e:	8c 91       	ld	r24, X
     520:	81 50       	subi	r24, 0x01	; 1
     522:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
     524:	df 91       	pop	r29
     526:	cf 91       	pop	r28
     528:	08 95       	ret

0000052a <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     52a:	31 e1       	ldi	r19, 0x11	; 17
     52c:	fc 01       	movw	r30, r24
     52e:	30 83       	st	Z, r19
     530:	31 97       	sbiw	r30, 0x01	; 1
     532:	22 e2       	ldi	r18, 0x22	; 34
     534:	20 83       	st	Z, r18
     536:	31 97       	sbiw	r30, 0x01	; 1
     538:	a3 e3       	ldi	r26, 0x33	; 51
     53a:	a0 83       	st	Z, r26
     53c:	31 97       	sbiw	r30, 0x01	; 1
     53e:	60 83       	st	Z, r22
     540:	31 97       	sbiw	r30, 0x01	; 1
     542:	70 83       	st	Z, r23
     544:	31 97       	sbiw	r30, 0x01	; 1
     546:	10 82       	st	Z, r1
     548:	31 97       	sbiw	r30, 0x01	; 1
     54a:	60 e8       	ldi	r22, 0x80	; 128
     54c:	60 83       	st	Z, r22
     54e:	31 97       	sbiw	r30, 0x01	; 1
     550:	10 82       	st	Z, r1
     552:	31 97       	sbiw	r30, 0x01	; 1
     554:	62 e0       	ldi	r22, 0x02	; 2
     556:	60 83       	st	Z, r22
     558:	31 97       	sbiw	r30, 0x01	; 1
     55a:	63 e0       	ldi	r22, 0x03	; 3
     55c:	60 83       	st	Z, r22
     55e:	31 97       	sbiw	r30, 0x01	; 1
     560:	64 e0       	ldi	r22, 0x04	; 4
     562:	60 83       	st	Z, r22
     564:	31 97       	sbiw	r30, 0x01	; 1
     566:	65 e0       	ldi	r22, 0x05	; 5
     568:	60 83       	st	Z, r22
     56a:	31 97       	sbiw	r30, 0x01	; 1
     56c:	66 e0       	ldi	r22, 0x06	; 6
     56e:	60 83       	st	Z, r22
     570:	31 97       	sbiw	r30, 0x01	; 1
     572:	67 e0       	ldi	r22, 0x07	; 7
     574:	60 83       	st	Z, r22
     576:	31 97       	sbiw	r30, 0x01	; 1
     578:	68 e0       	ldi	r22, 0x08	; 8
     57a:	60 83       	st	Z, r22
     57c:	31 97       	sbiw	r30, 0x01	; 1
     57e:	69 e0       	ldi	r22, 0x09	; 9
     580:	60 83       	st	Z, r22
     582:	31 97       	sbiw	r30, 0x01	; 1
     584:	60 e1       	ldi	r22, 0x10	; 16
     586:	60 83       	st	Z, r22
     588:	31 97       	sbiw	r30, 0x01	; 1
     58a:	30 83       	st	Z, r19
     58c:	31 97       	sbiw	r30, 0x01	; 1
     58e:	32 e1       	ldi	r19, 0x12	; 18
     590:	30 83       	st	Z, r19
     592:	31 97       	sbiw	r30, 0x01	; 1
     594:	33 e1       	ldi	r19, 0x13	; 19
     596:	30 83       	st	Z, r19
     598:	31 97       	sbiw	r30, 0x01	; 1
     59a:	34 e1       	ldi	r19, 0x14	; 20
     59c:	30 83       	st	Z, r19
     59e:	31 97       	sbiw	r30, 0x01	; 1
     5a0:	35 e1       	ldi	r19, 0x15	; 21
     5a2:	30 83       	st	Z, r19
     5a4:	31 97       	sbiw	r30, 0x01	; 1
     5a6:	36 e1       	ldi	r19, 0x16	; 22
     5a8:	30 83       	st	Z, r19
     5aa:	31 97       	sbiw	r30, 0x01	; 1
     5ac:	37 e1       	ldi	r19, 0x17	; 23
     5ae:	30 83       	st	Z, r19
     5b0:	31 97       	sbiw	r30, 0x01	; 1
     5b2:	38 e1       	ldi	r19, 0x18	; 24
     5b4:	30 83       	st	Z, r19
     5b6:	31 97       	sbiw	r30, 0x01	; 1
     5b8:	39 e1       	ldi	r19, 0x19	; 25
     5ba:	30 83       	st	Z, r19
     5bc:	31 97       	sbiw	r30, 0x01	; 1
     5be:	30 e2       	ldi	r19, 0x20	; 32
     5c0:	30 83       	st	Z, r19
     5c2:	31 97       	sbiw	r30, 0x01	; 1
     5c4:	31 e2       	ldi	r19, 0x21	; 33
     5c6:	30 83       	st	Z, r19
     5c8:	31 97       	sbiw	r30, 0x01	; 1
     5ca:	20 83       	st	Z, r18
     5cc:	31 97       	sbiw	r30, 0x01	; 1
     5ce:	23 e2       	ldi	r18, 0x23	; 35
     5d0:	20 83       	st	Z, r18
     5d2:	31 97       	sbiw	r30, 0x01	; 1
     5d4:	40 83       	st	Z, r20
     5d6:	31 97       	sbiw	r30, 0x01	; 1
     5d8:	50 83       	st	Z, r21
     5da:	31 97       	sbiw	r30, 0x01	; 1
     5dc:	26 e2       	ldi	r18, 0x26	; 38
     5de:	20 83       	st	Z, r18
     5e0:	31 97       	sbiw	r30, 0x01	; 1
     5e2:	27 e2       	ldi	r18, 0x27	; 39
     5e4:	20 83       	st	Z, r18
     5e6:	31 97       	sbiw	r30, 0x01	; 1
     5e8:	28 e2       	ldi	r18, 0x28	; 40
     5ea:	20 83       	st	Z, r18
     5ec:	31 97       	sbiw	r30, 0x01	; 1
     5ee:	29 e2       	ldi	r18, 0x29	; 41
     5f0:	20 83       	st	Z, r18
     5f2:	31 97       	sbiw	r30, 0x01	; 1
     5f4:	20 e3       	ldi	r18, 0x30	; 48
     5f6:	20 83       	st	Z, r18
     5f8:	31 97       	sbiw	r30, 0x01	; 1
     5fa:	21 e3       	ldi	r18, 0x31	; 49
     5fc:	20 83       	st	Z, r18
     5fe:	86 97       	sbiw	r24, 0x26	; 38
     600:	08 95       	ret

00000602 <xPortStartScheduler>:
     602:	10 92 89 00 	sts	0x0089, r1	; 0x800089 <__TEXT_REGION_LENGTH__+0x7e0089>
     606:	85 ee       	ldi	r24, 0xE5	; 229
     608:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x7e0088>
     60c:	8b e0       	ldi	r24, 0x0B	; 11
     60e:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x7e0081>
     612:	ef e6       	ldi	r30, 0x6F	; 111
     614:	f0 e0       	ldi	r31, 0x00	; 0
     616:	80 81       	ld	r24, Z
     618:	82 60       	ori	r24, 0x02	; 2
     61a:	80 83       	st	Z, r24
     61c:	a0 91 e4 05 	lds	r26, 0x05E4	; 0x8005e4 <pxCurrentTCB>
     620:	b0 91 e5 05 	lds	r27, 0x05E5	; 0x8005e5 <pxCurrentTCB+0x1>
     624:	cd 91       	ld	r28, X+
     626:	cd bf       	out	0x3d, r28	; 61
     628:	dd 91       	ld	r29, X+
     62a:	de bf       	out	0x3e, r29	; 62
     62c:	ff 91       	pop	r31
     62e:	ef 91       	pop	r30
     630:	df 91       	pop	r29
     632:	cf 91       	pop	r28
     634:	bf 91       	pop	r27
     636:	af 91       	pop	r26
     638:	9f 91       	pop	r25
     63a:	8f 91       	pop	r24
     63c:	7f 91       	pop	r23
     63e:	6f 91       	pop	r22
     640:	5f 91       	pop	r21
     642:	4f 91       	pop	r20
     644:	3f 91       	pop	r19
     646:	2f 91       	pop	r18
     648:	1f 91       	pop	r17
     64a:	0f 91       	pop	r16
     64c:	ff 90       	pop	r15
     64e:	ef 90       	pop	r14
     650:	df 90       	pop	r13
     652:	cf 90       	pop	r12
     654:	bf 90       	pop	r11
     656:	af 90       	pop	r10
     658:	9f 90       	pop	r9
     65a:	8f 90       	pop	r8
     65c:	7f 90       	pop	r7
     65e:	6f 90       	pop	r6
     660:	5f 90       	pop	r5
     662:	4f 90       	pop	r4
     664:	3f 90       	pop	r3
     666:	2f 90       	pop	r2
     668:	1f 90       	pop	r1
     66a:	0f 90       	pop	r0
     66c:	0f be       	out	0x3f, r0	; 63
     66e:	0f 90       	pop	r0
     670:	08 95       	ret
     672:	81 e0       	ldi	r24, 0x01	; 1
     674:	08 95       	ret

00000676 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     676:	0f 92       	push	r0
     678:	0f b6       	in	r0, 0x3f	; 63
     67a:	f8 94       	cli
     67c:	0f 92       	push	r0
     67e:	1f 92       	push	r1
     680:	11 24       	eor	r1, r1
     682:	2f 92       	push	r2
     684:	3f 92       	push	r3
     686:	4f 92       	push	r4
     688:	5f 92       	push	r5
     68a:	6f 92       	push	r6
     68c:	7f 92       	push	r7
     68e:	8f 92       	push	r8
     690:	9f 92       	push	r9
     692:	af 92       	push	r10
     694:	bf 92       	push	r11
     696:	cf 92       	push	r12
     698:	df 92       	push	r13
     69a:	ef 92       	push	r14
     69c:	ff 92       	push	r15
     69e:	0f 93       	push	r16
     6a0:	1f 93       	push	r17
     6a2:	2f 93       	push	r18
     6a4:	3f 93       	push	r19
     6a6:	4f 93       	push	r20
     6a8:	5f 93       	push	r21
     6aa:	6f 93       	push	r22
     6ac:	7f 93       	push	r23
     6ae:	8f 93       	push	r24
     6b0:	9f 93       	push	r25
     6b2:	af 93       	push	r26
     6b4:	bf 93       	push	r27
     6b6:	cf 93       	push	r28
     6b8:	df 93       	push	r29
     6ba:	ef 93       	push	r30
     6bc:	ff 93       	push	r31
     6be:	a0 91 e4 05 	lds	r26, 0x05E4	; 0x8005e4 <pxCurrentTCB>
     6c2:	b0 91 e5 05 	lds	r27, 0x05E5	; 0x8005e5 <pxCurrentTCB+0x1>
     6c6:	0d b6       	in	r0, 0x3d	; 61
     6c8:	0d 92       	st	X+, r0
     6ca:	0e b6       	in	r0, 0x3e	; 62
     6cc:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     6ce:	0e 94 22 0b 	call	0x1644	; 0x1644 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     6d2:	a0 91 e4 05 	lds	r26, 0x05E4	; 0x8005e4 <pxCurrentTCB>
     6d6:	b0 91 e5 05 	lds	r27, 0x05E5	; 0x8005e5 <pxCurrentTCB+0x1>
     6da:	cd 91       	ld	r28, X+
     6dc:	cd bf       	out	0x3d, r28	; 61
     6de:	dd 91       	ld	r29, X+
     6e0:	de bf       	out	0x3e, r29	; 62
     6e2:	ff 91       	pop	r31
     6e4:	ef 91       	pop	r30
     6e6:	df 91       	pop	r29
     6e8:	cf 91       	pop	r28
     6ea:	bf 91       	pop	r27
     6ec:	af 91       	pop	r26
     6ee:	9f 91       	pop	r25
     6f0:	8f 91       	pop	r24
     6f2:	7f 91       	pop	r23
     6f4:	6f 91       	pop	r22
     6f6:	5f 91       	pop	r21
     6f8:	4f 91       	pop	r20
     6fa:	3f 91       	pop	r19
     6fc:	2f 91       	pop	r18
     6fe:	1f 91       	pop	r17
     700:	0f 91       	pop	r16
     702:	ff 90       	pop	r15
     704:	ef 90       	pop	r14
     706:	df 90       	pop	r13
     708:	cf 90       	pop	r12
     70a:	bf 90       	pop	r11
     70c:	af 90       	pop	r10
     70e:	9f 90       	pop	r9
     710:	8f 90       	pop	r8
     712:	7f 90       	pop	r7
     714:	6f 90       	pop	r6
     716:	5f 90       	pop	r5
     718:	4f 90       	pop	r4
     71a:	3f 90       	pop	r3
     71c:	2f 90       	pop	r2
     71e:	1f 90       	pop	r1
     720:	0f 90       	pop	r0
     722:	0f be       	out	0x3f, r0	; 63
     724:	0f 90       	pop	r0

	asm volatile ( "ret" );
     726:	08 95       	ret

00000728 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     728:	0f 92       	push	r0
     72a:	0f b6       	in	r0, 0x3f	; 63
     72c:	f8 94       	cli
     72e:	0f 92       	push	r0
     730:	1f 92       	push	r1
     732:	11 24       	eor	r1, r1
     734:	2f 92       	push	r2
     736:	3f 92       	push	r3
     738:	4f 92       	push	r4
     73a:	5f 92       	push	r5
     73c:	6f 92       	push	r6
     73e:	7f 92       	push	r7
     740:	8f 92       	push	r8
     742:	9f 92       	push	r9
     744:	af 92       	push	r10
     746:	bf 92       	push	r11
     748:	cf 92       	push	r12
     74a:	df 92       	push	r13
     74c:	ef 92       	push	r14
     74e:	ff 92       	push	r15
     750:	0f 93       	push	r16
     752:	1f 93       	push	r17
     754:	2f 93       	push	r18
     756:	3f 93       	push	r19
     758:	4f 93       	push	r20
     75a:	5f 93       	push	r21
     75c:	6f 93       	push	r22
     75e:	7f 93       	push	r23
     760:	8f 93       	push	r24
     762:	9f 93       	push	r25
     764:	af 93       	push	r26
     766:	bf 93       	push	r27
     768:	cf 93       	push	r28
     76a:	df 93       	push	r29
     76c:	ef 93       	push	r30
     76e:	ff 93       	push	r31
     770:	a0 91 e4 05 	lds	r26, 0x05E4	; 0x8005e4 <pxCurrentTCB>
     774:	b0 91 e5 05 	lds	r27, 0x05E5	; 0x8005e5 <pxCurrentTCB+0x1>
     778:	0d b6       	in	r0, 0x3d	; 61
     77a:	0d 92       	st	X+, r0
     77c:	0e b6       	in	r0, 0x3e	; 62
     77e:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
     780:	0e 94 a9 09 	call	0x1352	; 0x1352 <xTaskIncrementTick>
     784:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
     786:	0e 94 22 0b 	call	0x1644	; 0x1644 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
     78a:	a0 91 e4 05 	lds	r26, 0x05E4	; 0x8005e4 <pxCurrentTCB>
     78e:	b0 91 e5 05 	lds	r27, 0x05E5	; 0x8005e5 <pxCurrentTCB+0x1>
     792:	cd 91       	ld	r28, X+
     794:	cd bf       	out	0x3d, r28	; 61
     796:	dd 91       	ld	r29, X+
     798:	de bf       	out	0x3e, r29	; 62
     79a:	ff 91       	pop	r31
     79c:	ef 91       	pop	r30
     79e:	df 91       	pop	r29
     7a0:	cf 91       	pop	r28
     7a2:	bf 91       	pop	r27
     7a4:	af 91       	pop	r26
     7a6:	9f 91       	pop	r25
     7a8:	8f 91       	pop	r24
     7aa:	7f 91       	pop	r23
     7ac:	6f 91       	pop	r22
     7ae:	5f 91       	pop	r21
     7b0:	4f 91       	pop	r20
     7b2:	3f 91       	pop	r19
     7b4:	2f 91       	pop	r18
     7b6:	1f 91       	pop	r17
     7b8:	0f 91       	pop	r16
     7ba:	ff 90       	pop	r15
     7bc:	ef 90       	pop	r14
     7be:	df 90       	pop	r13
     7c0:	cf 90       	pop	r12
     7c2:	bf 90       	pop	r11
     7c4:	af 90       	pop	r10
     7c6:	9f 90       	pop	r9
     7c8:	8f 90       	pop	r8
     7ca:	7f 90       	pop	r7
     7cc:	6f 90       	pop	r6
     7ce:	5f 90       	pop	r5
     7d0:	4f 90       	pop	r4
     7d2:	3f 90       	pop	r3
     7d4:	2f 90       	pop	r2
     7d6:	1f 90       	pop	r1
     7d8:	0f 90       	pop	r0
     7da:	0f be       	out	0x3f, r0	; 63
     7dc:	0f 90       	pop	r0

	asm volatile ( "ret" );
     7de:	08 95       	ret

000007e0 <__vector_13>:
	 */
// 	void SIG_OUTPUT_COMPARE1A( void ) __attribute__ ( ( signal, naked ) );
// 	void SIG_OUTPUT_COMPARE1A( void )
ISR(TIMER1_COMPA_vect, ISR_NAKED)  // IHA
	{
		vPortYieldFromTick();
     7e0:	0e 94 94 03 	call	0x728	; 0x728 <vPortYieldFromTick>
		asm volatile ( "reti" );
     7e4:	18 95       	reti

000007e6 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     7e6:	cf 93       	push	r28
     7e8:	df 93       	push	r29
     7ea:	ec 01       	movw	r28, r24
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	}
	#endif

	vTaskSuspendAll();
     7ec:	0e 94 a3 09 	call	0x1346	; 0x1346 <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
     7f0:	80 91 99 01 	lds	r24, 0x0199	; 0x800199 <pucAlignedHeap.2084>
     7f4:	90 91 9a 01 	lds	r25, 0x019A	; 0x80019a <pucAlignedHeap.2084+0x1>
     7f8:	89 2b       	or	r24, r25
     7fa:	31 f4       	brne	.+12     	; 0x808 <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
     7fc:	8e e9       	ldi	r24, 0x9E	; 158
     7fe:	91 e0       	ldi	r25, 0x01	; 1
     800:	90 93 9a 01 	sts	0x019A, r25	; 0x80019a <pucAlignedHeap.2084+0x1>
     804:	80 93 99 01 	sts	0x0199, r24	; 0x800199 <pucAlignedHeap.2084>
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
     808:	20 91 9b 01 	lds	r18, 0x019B	; 0x80019b <xNextFreeByte>
     80c:	30 91 9c 01 	lds	r19, 0x019C	; 0x80019c <xNextFreeByte+0x1>
     810:	c9 01       	movw	r24, r18
     812:	8c 0f       	add	r24, r28
     814:	9d 1f       	adc	r25, r29
     816:	87 3e       	cpi	r24, 0xE7	; 231
     818:	43 e0       	ldi	r20, 0x03	; 3
     81a:	94 07       	cpc	r25, r20
     81c:	70 f4       	brcc	.+28     	; 0x83a <pvPortMalloc+0x54>
     81e:	28 17       	cp	r18, r24
     820:	39 07       	cpc	r19, r25
     822:	70 f4       	brcc	.+28     	; 0x840 <pvPortMalloc+0x5a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
     824:	c0 91 99 01 	lds	r28, 0x0199	; 0x800199 <pucAlignedHeap.2084>
     828:	d0 91 9a 01 	lds	r29, 0x019A	; 0x80019a <pucAlignedHeap.2084+0x1>
     82c:	c2 0f       	add	r28, r18
     82e:	d3 1f       	adc	r29, r19
			xNextFreeByte += xWantedSize;
     830:	90 93 9c 01 	sts	0x019C, r25	; 0x80019c <xNextFreeByte+0x1>
     834:	80 93 9b 01 	sts	0x019B, r24	; 0x80019b <xNextFreeByte>
     838:	05 c0       	rjmp	.+10     	; 0x844 <pvPortMalloc+0x5e>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
     83a:	c0 e0       	ldi	r28, 0x00	; 0
     83c:	d0 e0       	ldi	r29, 0x00	; 0
     83e:	02 c0       	rjmp	.+4      	; 0x844 <pvPortMalloc+0x5e>
     840:	c0 e0       	ldi	r28, 0x00	; 0
     842:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     844:	0e 94 64 0a 	call	0x14c8	; 0x14c8 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     848:	ce 01       	movw	r24, r28
     84a:	df 91       	pop	r29
     84c:	cf 91       	pop	r28
     84e:	08 95       	ret

00000850 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     850:	08 95       	ret

00000852 <serial_new_instance>:
			_serial_tx_int_on(handle->ser_UDR);
			return BUFFER_OK;
		}
	}
	return BUFFER_FULL;
}
     852:	4f 92       	push	r4
     854:	5f 92       	push	r5
     856:	6f 92       	push	r6
     858:	7f 92       	push	r7
     85a:	8f 92       	push	r8
     85c:	9f 92       	push	r9
     85e:	af 92       	push	r10
     860:	bf 92       	push	r11
     862:	cf 92       	push	r12
     864:	df 92       	push	r13
     866:	ff 92       	push	r15
     868:	0f 93       	push	r16
     86a:	1f 93       	push	r17
     86c:	cf 93       	push	r28
     86e:	df 93       	push	r29
     870:	cd b7       	in	r28, 0x3d	; 61
     872:	de b7       	in	r29, 0x3e	; 62
     874:	f8 2e       	mov	r15, r24
     876:	2a 01       	movw	r4, r20
     878:	3b 01       	movw	r6, r22
     87a:	88 e0       	ldi	r24, 0x08	; 8
     87c:	90 e0       	ldi	r25, 0x00	; 0
     87e:	0e 94 93 0c 	call	0x1926	; 0x1926 <malloc>
     882:	8c 01       	movw	r16, r24
     884:	8f 2d       	mov	r24, r15
     886:	90 e0       	ldi	r25, 0x00	; 0
     888:	88 0f       	add	r24, r24
     88a:	99 1f       	adc	r25, r25
     88c:	fc 01       	movw	r30, r24
     88e:	eb 57       	subi	r30, 0x7B	; 123
     890:	fa 4f       	sbci	r31, 0xFA	; 250
     892:	11 83       	std	Z+1, r17	; 0x01
     894:	00 83       	st	Z, r16
     896:	fc 01       	movw	r30, r24
     898:	ea 5f       	subi	r30, 0xFA	; 250
     89a:	fe 4f       	sbci	r31, 0xFE	; 254
     89c:	80 81       	ld	r24, Z
     89e:	91 81       	ldd	r25, Z+1	; 0x01
     8a0:	d8 01       	movw	r26, r16
     8a2:	11 96       	adiw	r26, 0x01	; 1
     8a4:	9c 93       	st	X, r25
     8a6:	8e 93       	st	-X, r24
     8a8:	13 96       	adiw	r26, 0x03	; 3
     8aa:	bc 92       	st	X, r11
     8ac:	ae 92       	st	-X, r10
     8ae:	12 97       	sbiw	r26, 0x02	; 2
     8b0:	15 96       	adiw	r26, 0x05	; 5
     8b2:	dc 92       	st	X, r13
     8b4:	ce 92       	st	-X, r12
     8b6:	14 97       	sbiw	r26, 0x04	; 4
     8b8:	17 96       	adiw	r26, 0x07	; 7
     8ba:	9c 92       	st	X, r9
     8bc:	8e 92       	st	-X, r8
     8be:	16 97       	sbiw	r26, 0x06	; 6
     8c0:	ff b6       	in	r15, 0x3f	; 63
     8c2:	f8 94       	cli
     8c4:	ed 91       	ld	r30, X+
     8c6:	fc 91       	ld	r31, X
     8c8:	11 97       	sbiw	r26, 0x01	; 1
     8ca:	36 97       	sbiw	r30, 0x06	; 6
     8cc:	80 81       	ld	r24, Z
     8ce:	82 60       	ori	r24, 0x02	; 2
     8d0:	80 83       	st	Z, r24
     8d2:	cd 90       	ld	r12, X+
     8d4:	dc 90       	ld	r13, X
     8d6:	d3 01       	movw	r26, r6
     8d8:	c2 01       	movw	r24, r4
     8da:	88 0f       	add	r24, r24
     8dc:	99 1f       	adc	r25, r25
     8de:	aa 1f       	adc	r26, r26
     8e0:	bb 1f       	adc	r27, r27
     8e2:	88 0f       	add	r24, r24
     8e4:	99 1f       	adc	r25, r25
     8e6:	aa 1f       	adc	r26, r26
     8e8:	bb 1f       	adc	r27, r27
     8ea:	9c 01       	movw	r18, r24
     8ec:	ad 01       	movw	r20, r26
     8ee:	22 0f       	add	r18, r18
     8f0:	33 1f       	adc	r19, r19
     8f2:	44 1f       	adc	r20, r20
     8f4:	55 1f       	adc	r21, r21
     8f6:	60 e0       	ldi	r22, 0x00	; 0
     8f8:	70 e0       	ldi	r23, 0x00	; 0
     8fa:	81 ee       	ldi	r24, 0xE1	; 225
     8fc:	90 e0       	ldi	r25, 0x00	; 0
     8fe:	0e 94 71 0c 	call	0x18e2	; 0x18e2 <__udivmodsi4>
     902:	21 50       	subi	r18, 0x01	; 1
     904:	f6 01       	movw	r30, r12
     906:	32 97       	sbiw	r30, 0x02	; 2
     908:	20 83       	st	Z, r18
     90a:	d8 01       	movw	r26, r16
     90c:	ed 91       	ld	r30, X+
     90e:	fc 91       	ld	r31, X
     910:	11 97       	sbiw	r26, 0x01	; 1
     912:	35 97       	sbiw	r30, 0x05	; 5
     914:	88 e9       	ldi	r24, 0x98	; 152
     916:	80 83       	st	Z, r24
     918:	ed 91       	ld	r30, X+
     91a:	fc 91       	ld	r31, X
     91c:	34 97       	sbiw	r30, 0x04	; 4
     91e:	86 e0       	ldi	r24, 0x06	; 6
     920:	80 83       	st	Z, r24
     922:	ff be       	out	0x3f, r15	; 63
     924:	c8 01       	movw	r24, r16
     926:	df 91       	pop	r29
     928:	cf 91       	pop	r28
     92a:	1f 91       	pop	r17
     92c:	0f 91       	pop	r16
     92e:	ff 90       	pop	r15
     930:	df 90       	pop	r13
     932:	cf 90       	pop	r12
     934:	bf 90       	pop	r11
     936:	af 90       	pop	r10
     938:	9f 90       	pop	r9
     93a:	8f 90       	pop	r8
     93c:	7f 90       	pop	r7
     93e:	6f 90       	pop	r6
     940:	5f 90       	pop	r5
     942:	4f 90       	pop	r4
     944:	08 95       	ret

00000946 <serial_send_bytes>:

/*-----------------------------------------------------------*/
uint8_t serial_send_bytes(serial_p handle, uint8_t *buf, uint8_t len )
{
     946:	ef 92       	push	r14
     948:	ff 92       	push	r15
     94a:	0f 93       	push	r16
     94c:	1f 93       	push	r17
     94e:	cf 93       	push	r28
     950:	df 93       	push	r29
	// Check if buffer is full
	if ( ((handle->_tx_buf != 0) && (len > (BUFFER_SIZE - handle->_tx_buf->no_in_buffer))) || ((handle->_tx_buf == 0) && (len > 1)) ) {
     952:	fc 01       	movw	r30, r24
     954:	a2 81       	ldd	r26, Z+2	; 0x02
     956:	b3 81       	ldd	r27, Z+3	; 0x03
     958:	10 97       	sbiw	r26, 0x00	; 0
     95a:	79 f0       	breq	.+30     	; 0x97a <serial_send_bytes+0x34>
     95c:	e4 2f       	mov	r30, r20
     95e:	f0 e0       	ldi	r31, 0x00	; 0
     960:	92 96       	adiw	r26, 0x22	; 34
     962:	5c 91       	ld	r21, X
     964:	20 e2       	ldi	r18, 0x20	; 32
     966:	30 e0       	ldi	r19, 0x00	; 0
     968:	25 1b       	sub	r18, r21
     96a:	31 09       	sbc	r19, r1
     96c:	2e 17       	cp	r18, r30
     96e:	3f 07       	cpc	r19, r31
     970:	1c f1       	brlt	.+70     	; 0x9b8 <serial_send_bytes+0x72>
     972:	7c 01       	movw	r14, r24
		return BUFFER_FULL;
	}
	
	// Put in the tx buffer
	for (uint8_t i = 0; i < len; i++) {
     974:	41 11       	cpse	r20, r1
     976:	04 c0       	rjmp	.+8      	; 0x980 <serial_send_bytes+0x3a>
     978:	16 c0       	rjmp	.+44     	; 0x9a6 <serial_send_bytes+0x60>

/*-----------------------------------------------------------*/
uint8_t serial_send_bytes(serial_p handle, uint8_t *buf, uint8_t len )
{
	// Check if buffer is full
	if ( ((handle->_tx_buf != 0) && (len > (BUFFER_SIZE - handle->_tx_buf->no_in_buffer))) || ((handle->_tx_buf == 0) && (len > 1)) ) {
     97a:	42 30       	cpi	r20, 0x02	; 2
     97c:	f8 f4       	brcc	.+62     	; 0x9bc <serial_send_bytes+0x76>
     97e:	f9 cf       	rjmp	.-14     	; 0x972 <serial_send_bytes+0x2c>
     980:	eb 01       	movw	r28, r22
     982:	41 50       	subi	r20, 0x01	; 1
     984:	04 2f       	mov	r16, r20
     986:	10 e0       	ldi	r17, 0x00	; 0
     988:	0f 5f       	subi	r16, 0xFF	; 255
     98a:	1f 4f       	sbci	r17, 0xFF	; 255
     98c:	06 0f       	add	r16, r22
     98e:	17 1f       	adc	r17, r23
		return BUFFER_FULL;
	}
	
	// Put in the tx buffer
	for (uint8_t i = 0; i < len; i++) {
		buffer_put_item(handle->_tx_buf, buf[i]);
     990:	69 91       	ld	r22, Y+
     992:	d7 01       	movw	r26, r14
     994:	12 96       	adiw	r26, 0x02	; 2
     996:	8d 91       	ld	r24, X+
     998:	9c 91       	ld	r25, X
     99a:	13 97       	sbiw	r26, 0x03	; 3
     99c:	0e 94 ee 01 	call	0x3dc	; 0x3dc <buffer_put_item>
	if ( ((handle->_tx_buf != 0) && (len > (BUFFER_SIZE - handle->_tx_buf->no_in_buffer))) || ((handle->_tx_buf == 0) && (len > 1)) ) {
		return BUFFER_FULL;
	}
	
	// Put in the tx buffer
	for (uint8_t i = 0; i < len; i++) {
     9a0:	c0 17       	cp	r28, r16
     9a2:	d1 07       	cpc	r29, r17
     9a4:	a9 f7       	brne	.-22     	; 0x990 <serial_send_bytes+0x4a>
		buffer_put_item(handle->_tx_buf, buf[i]);
	}
	_serial_tx_int_on(handle->ser_UDR);
     9a6:	d7 01       	movw	r26, r14
     9a8:	ed 91       	ld	r30, X+
     9aa:	fc 91       	ld	r31, X
SREG = _sreg;


/*-----------------------------------------------------------*/
static void _serial_tx_int_on(volatile uint8_t *UDR_reg) {
	*(UDR_reg  - UCSRB_off) |= serTX_INT_ENABLE;
     9ac:	35 97       	sbiw	r30, 0x05	; 5
     9ae:	80 81       	ld	r24, Z
     9b0:	80 62       	ori	r24, 0x20	; 32
     9b2:	80 83       	st	Z, r24
	// Put in the tx buffer
	for (uint8_t i = 0; i < len; i++) {
		buffer_put_item(handle->_tx_buf, buf[i]);
	}
	_serial_tx_int_on(handle->ser_UDR);
	return BUFFER_OK;
     9b4:	80 e0       	ldi	r24, 0x00	; 0
     9b6:	03 c0       	rjmp	.+6      	; 0x9be <serial_send_bytes+0x78>
/*-----------------------------------------------------------*/
uint8_t serial_send_bytes(serial_p handle, uint8_t *buf, uint8_t len )
{
	// Check if buffer is full
	if ( ((handle->_tx_buf != 0) && (len > (BUFFER_SIZE - handle->_tx_buf->no_in_buffer))) || ((handle->_tx_buf == 0) && (len > 1)) ) {
		return BUFFER_FULL;
     9b8:	82 e0       	ldi	r24, 0x02	; 2
     9ba:	01 c0       	rjmp	.+2      	; 0x9be <serial_send_bytes+0x78>
     9bc:	82 e0       	ldi	r24, 0x02	; 2
	for (uint8_t i = 0; i < len; i++) {
		buffer_put_item(handle->_tx_buf, buf[i]);
	}
	_serial_tx_int_on(handle->ser_UDR);
	return BUFFER_OK;
}
     9be:	df 91       	pop	r29
     9c0:	cf 91       	pop	r28
     9c2:	1f 91       	pop	r17
     9c4:	0f 91       	pop	r16
     9c6:	ff 90       	pop	r15
     9c8:	ef 90       	pop	r14
     9ca:	08 95       	ret

000009cc <__vector_20>:

/*-----------------------------------------------------------*/
ISR(USART0_RX_vect)
{
     9cc:	1f 92       	push	r1
     9ce:	0f 92       	push	r0
     9d0:	0f b6       	in	r0, 0x3f	; 63
     9d2:	0f 92       	push	r0
     9d4:	11 24       	eor	r1, r1
     9d6:	2f 93       	push	r18
     9d8:	3f 93       	push	r19
     9da:	4f 93       	push	r20
     9dc:	5f 93       	push	r21
     9de:	6f 93       	push	r22
     9e0:	7f 93       	push	r23
     9e2:	8f 93       	push	r24
     9e4:	9f 93       	push	r25
     9e6:	af 93       	push	r26
     9e8:	bf 93       	push	r27
     9ea:	cf 93       	push	r28
     9ec:	ef 93       	push	r30
     9ee:	ff 93       	push	r31
	uint8_t item;
	if (_ser_handle[ser_USART0]) {
     9f0:	e0 91 85 05 	lds	r30, 0x0585	; 0x800585 <_ser_handle>
     9f4:	f0 91 86 05 	lds	r31, 0x0586	; 0x800586 <_ser_handle+0x1>
     9f8:	30 97       	sbiw	r30, 0x00	; 0
     9fa:	a1 f0       	breq	.+40     	; 0xa24 <__vector_20+0x58>
		item = UDR0;
     9fc:	c0 91 c6 00 	lds	r28, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
		buffer_put_item(_ser_handle[ser_USART0]->_rx_buf, item);
     a00:	6c 2f       	mov	r22, r28
     a02:	84 81       	ldd	r24, Z+4	; 0x04
     a04:	95 81       	ldd	r25, Z+5	; 0x05
     a06:	0e 94 ee 01 	call	0x3dc	; 0x3dc <buffer_put_item>
		
		if (_ser_handle[ser_USART0]->_call_back) {
     a0a:	80 91 85 05 	lds	r24, 0x0585	; 0x800585 <_ser_handle>
     a0e:	90 91 86 05 	lds	r25, 0x0586	; 0x800586 <_ser_handle+0x1>
     a12:	dc 01       	movw	r26, r24
     a14:	16 96       	adiw	r26, 0x06	; 6
     a16:	ed 91       	ld	r30, X+
     a18:	fc 91       	ld	r31, X
     a1a:	17 97       	sbiw	r26, 0x07	; 7
     a1c:	30 97       	sbiw	r30, 0x00	; 0
     a1e:	11 f0       	breq	.+4      	; 0xa24 <__vector_20+0x58>
			_ser_handle[ser_USART0]->_call_back(_ser_handle[ser_USART0], item);
     a20:	6c 2f       	mov	r22, r28
     a22:	09 95       	icall
		}
	}
}
     a24:	ff 91       	pop	r31
     a26:	ef 91       	pop	r30
     a28:	cf 91       	pop	r28
     a2a:	bf 91       	pop	r27
     a2c:	af 91       	pop	r26
     a2e:	9f 91       	pop	r25
     a30:	8f 91       	pop	r24
     a32:	7f 91       	pop	r23
     a34:	6f 91       	pop	r22
     a36:	5f 91       	pop	r21
     a38:	4f 91       	pop	r20
     a3a:	3f 91       	pop	r19
     a3c:	2f 91       	pop	r18
     a3e:	0f 90       	pop	r0
     a40:	0f be       	out	0x3f, r0	; 63
     a42:	0f 90       	pop	r0
     a44:	1f 90       	pop	r1
     a46:	18 95       	reti

00000a48 <__vector_21>:

/*-----------------------------------------------------------*/
ISR(USART0_UDRE_vect)
{
     a48:	1f 92       	push	r1
     a4a:	0f 92       	push	r0
     a4c:	0f b6       	in	r0, 0x3f	; 63
     a4e:	0f 92       	push	r0
     a50:	11 24       	eor	r1, r1
     a52:	2f 93       	push	r18
     a54:	3f 93       	push	r19
     a56:	4f 93       	push	r20
     a58:	5f 93       	push	r21
     a5a:	6f 93       	push	r22
     a5c:	7f 93       	push	r23
     a5e:	8f 93       	push	r24
     a60:	9f 93       	push	r25
     a62:	af 93       	push	r26
     a64:	bf 93       	push	r27
     a66:	ef 93       	push	r30
     a68:	ff 93       	push	r31
     a6a:	cf 93       	push	r28
     a6c:	df 93       	push	r29
     a6e:	1f 92       	push	r1
     a70:	cd b7       	in	r28, 0x3d	; 61
     a72:	de b7       	in	r29, 0x3e	; 62
	uint8_t item;
	if (_ser_handle[ser_USART0]) {
     a74:	e0 91 85 05 	lds	r30, 0x0585	; 0x800585 <_ser_handle>
     a78:	f0 91 86 05 	lds	r31, 0x0586	; 0x800586 <_ser_handle+0x1>
     a7c:	30 97       	sbiw	r30, 0x00	; 0
     a7e:	99 f0       	breq	.+38     	; 0xaa6 <__vector_21+0x5e>
		if ((buffer_get_item(_ser_handle[ser_USART0]->_tx_buf, &item) == BUFFER_OK)) {
     a80:	be 01       	movw	r22, r28
     a82:	6f 5f       	subi	r22, 0xFF	; 255
     a84:	7f 4f       	sbci	r23, 0xFF	; 255
     a86:	82 81       	ldd	r24, Z+2	; 0x02
     a88:	93 81       	ldd	r25, Z+3	; 0x03
     a8a:	0e 94 cd 01 	call	0x39a	; 0x39a <buffer_get_item>
     a8e:	81 11       	cpse	r24, r1
     a90:	04 c0       	rjmp	.+8      	; 0xa9a <__vector_21+0x52>
			UDR0 = item;
     a92:	89 81       	ldd	r24, Y+1	; 0x01
     a94:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
     a98:	0b c0       	rjmp	.+22     	; 0xab0 <__vector_21+0x68>
		}
		else
		{
			SERIAL_TX_INT_OFF(UCSR0B);
     a9a:	e1 ec       	ldi	r30, 0xC1	; 193
     a9c:	f0 e0       	ldi	r31, 0x00	; 0
     a9e:	80 81       	ld	r24, Z
     aa0:	8f 7d       	andi	r24, 0xDF	; 223
     aa2:	80 83       	st	Z, r24
     aa4:	05 c0       	rjmp	.+10     	; 0xab0 <__vector_21+0x68>
		}
	}
	
	else
	{
		SERIAL_TX_INT_OFF(UCSR0B);
     aa6:	e1 ec       	ldi	r30, 0xC1	; 193
     aa8:	f0 e0       	ldi	r31, 0x00	; 0
     aaa:	80 81       	ld	r24, Z
     aac:	8f 7d       	andi	r24, 0xDF	; 223
     aae:	80 83       	st	Z, r24
	}
}
     ab0:	0f 90       	pop	r0
     ab2:	df 91       	pop	r29
     ab4:	cf 91       	pop	r28
     ab6:	ff 91       	pop	r31
     ab8:	ef 91       	pop	r30
     aba:	bf 91       	pop	r27
     abc:	af 91       	pop	r26
     abe:	9f 91       	pop	r25
     ac0:	8f 91       	pop	r24
     ac2:	7f 91       	pop	r23
     ac4:	6f 91       	pop	r22
     ac6:	5f 91       	pop	r21
     ac8:	4f 91       	pop	r20
     aca:	3f 91       	pop	r19
     acc:	2f 91       	pop	r18
     ace:	0f 90       	pop	r0
     ad0:	0f be       	out	0x3f, r0	; 63
     ad2:	0f 90       	pop	r0
     ad4:	1f 90       	pop	r1
     ad6:	18 95       	reti

00000ad8 <__vector_28>:

/*-----------------------------------------------------------*/
ISR(USART1_RX_vect)
{
     ad8:	1f 92       	push	r1
     ada:	0f 92       	push	r0
     adc:	0f b6       	in	r0, 0x3f	; 63
     ade:	0f 92       	push	r0
     ae0:	11 24       	eor	r1, r1
     ae2:	2f 93       	push	r18
     ae4:	3f 93       	push	r19
     ae6:	4f 93       	push	r20
     ae8:	5f 93       	push	r21
     aea:	6f 93       	push	r22
     aec:	7f 93       	push	r23
     aee:	8f 93       	push	r24
     af0:	9f 93       	push	r25
     af2:	af 93       	push	r26
     af4:	bf 93       	push	r27
     af6:	cf 93       	push	r28
     af8:	ef 93       	push	r30
     afa:	ff 93       	push	r31
	uint8_t item;
	if (_ser_handle[ser_USART1]) {
     afc:	e0 91 87 05 	lds	r30, 0x0587	; 0x800587 <_ser_handle+0x2>
     b00:	f0 91 88 05 	lds	r31, 0x0588	; 0x800588 <_ser_handle+0x3>
     b04:	30 97       	sbiw	r30, 0x00	; 0
     b06:	a1 f0       	breq	.+40     	; 0xb30 <__vector_28+0x58>
		item = UDR1;
     b08:	c0 91 ce 00 	lds	r28, 0x00CE	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7e00ce>
		buffer_put_item(_ser_handle[ser_USART1]->_rx_buf, item);
     b0c:	6c 2f       	mov	r22, r28
     b0e:	84 81       	ldd	r24, Z+4	; 0x04
     b10:	95 81       	ldd	r25, Z+5	; 0x05
     b12:	0e 94 ee 01 	call	0x3dc	; 0x3dc <buffer_put_item>
		if (_ser_handle[ser_USART1]->_call_back) {
     b16:	80 91 87 05 	lds	r24, 0x0587	; 0x800587 <_ser_handle+0x2>
     b1a:	90 91 88 05 	lds	r25, 0x0588	; 0x800588 <_ser_handle+0x3>
     b1e:	dc 01       	movw	r26, r24
     b20:	16 96       	adiw	r26, 0x06	; 6
     b22:	ed 91       	ld	r30, X+
     b24:	fc 91       	ld	r31, X
     b26:	17 97       	sbiw	r26, 0x07	; 7
     b28:	30 97       	sbiw	r30, 0x00	; 0
     b2a:	11 f0       	breq	.+4      	; 0xb30 <__vector_28+0x58>
			_ser_handle[ser_USART1]->_call_back(_ser_handle[ser_USART1], item);
     b2c:	6c 2f       	mov	r22, r28
     b2e:	09 95       	icall
		}
	}
}
     b30:	ff 91       	pop	r31
     b32:	ef 91       	pop	r30
     b34:	cf 91       	pop	r28
     b36:	bf 91       	pop	r27
     b38:	af 91       	pop	r26
     b3a:	9f 91       	pop	r25
     b3c:	8f 91       	pop	r24
     b3e:	7f 91       	pop	r23
     b40:	6f 91       	pop	r22
     b42:	5f 91       	pop	r21
     b44:	4f 91       	pop	r20
     b46:	3f 91       	pop	r19
     b48:	2f 91       	pop	r18
     b4a:	0f 90       	pop	r0
     b4c:	0f be       	out	0x3f, r0	; 63
     b4e:	0f 90       	pop	r0
     b50:	1f 90       	pop	r1
     b52:	18 95       	reti

00000b54 <__vector_29>:

/*-----------------------------------------------------------*/
ISR(USART1_UDRE_vect)
{
     b54:	1f 92       	push	r1
     b56:	0f 92       	push	r0
     b58:	0f b6       	in	r0, 0x3f	; 63
     b5a:	0f 92       	push	r0
     b5c:	11 24       	eor	r1, r1
     b5e:	2f 93       	push	r18
     b60:	3f 93       	push	r19
     b62:	4f 93       	push	r20
     b64:	5f 93       	push	r21
     b66:	6f 93       	push	r22
     b68:	7f 93       	push	r23
     b6a:	8f 93       	push	r24
     b6c:	9f 93       	push	r25
     b6e:	af 93       	push	r26
     b70:	bf 93       	push	r27
     b72:	ef 93       	push	r30
     b74:	ff 93       	push	r31
     b76:	cf 93       	push	r28
     b78:	df 93       	push	r29
     b7a:	1f 92       	push	r1
     b7c:	cd b7       	in	r28, 0x3d	; 61
     b7e:	de b7       	in	r29, 0x3e	; 62
	uint8_t item;
	if (_ser_handle[ser_USART1]) {
     b80:	e0 91 87 05 	lds	r30, 0x0587	; 0x800587 <_ser_handle+0x2>
     b84:	f0 91 88 05 	lds	r31, 0x0588	; 0x800588 <_ser_handle+0x3>
     b88:	30 97       	sbiw	r30, 0x00	; 0
     b8a:	99 f0       	breq	.+38     	; 0xbb2 <__vector_29+0x5e>
		if ((buffer_get_item(_ser_handle[ser_USART1]->_tx_buf, &item) == BUFFER_OK)) {
     b8c:	be 01       	movw	r22, r28
     b8e:	6f 5f       	subi	r22, 0xFF	; 255
     b90:	7f 4f       	sbci	r23, 0xFF	; 255
     b92:	82 81       	ldd	r24, Z+2	; 0x02
     b94:	93 81       	ldd	r25, Z+3	; 0x03
     b96:	0e 94 cd 01 	call	0x39a	; 0x39a <buffer_get_item>
     b9a:	81 11       	cpse	r24, r1
     b9c:	04 c0       	rjmp	.+8      	; 0xba6 <__vector_29+0x52>
			UDR1 = item;
     b9e:	89 81       	ldd	r24, Y+1	; 0x01
     ba0:	80 93 ce 00 	sts	0x00CE, r24	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7e00ce>
     ba4:	0b c0       	rjmp	.+22     	; 0xbbc <__vector_29+0x68>
		}
		else
		{
			SERIAL_TX_INT_OFF(UCSR1B);
     ba6:	e9 ec       	ldi	r30, 0xC9	; 201
     ba8:	f0 e0       	ldi	r31, 0x00	; 0
     baa:	80 81       	ld	r24, Z
     bac:	8f 7d       	andi	r24, 0xDF	; 223
     bae:	80 83       	st	Z, r24
     bb0:	05 c0       	rjmp	.+10     	; 0xbbc <__vector_29+0x68>
		}
	}
	
	else
	{
		SERIAL_TX_INT_OFF(UCSR1B);
     bb2:	e9 ec       	ldi	r30, 0xC9	; 201
     bb4:	f0 e0       	ldi	r31, 0x00	; 0
     bb6:	80 81       	ld	r24, Z
     bb8:	8f 7d       	andi	r24, 0xDF	; 223
     bba:	80 83       	st	Z, r24
	}
}
     bbc:	0f 90       	pop	r0
     bbe:	df 91       	pop	r29
     bc0:	cf 91       	pop	r28
     bc2:	ff 91       	pop	r31
     bc4:	ef 91       	pop	r30
     bc6:	bf 91       	pop	r27
     bc8:	af 91       	pop	r26
     bca:	9f 91       	pop	r25
     bcc:	8f 91       	pop	r24
     bce:	7f 91       	pop	r23
     bd0:	6f 91       	pop	r22
     bd2:	5f 91       	pop	r21
     bd4:	4f 91       	pop	r20
     bd6:	3f 91       	pop	r19
     bd8:	2f 91       	pop	r18
     bda:	0f 90       	pop	r0
     bdc:	0f be       	out	0x3f, r0	; 63
     bde:	0f 90       	pop	r0
     be0:	1f 90       	pop	r1
     be2:	18 95       	reti

00000be4 <prvCopyDataToQueue>:
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
     be4:	0f 93       	push	r16
     be6:	1f 93       	push	r17
     be8:	cf 93       	push	r28
     bea:	df 93       	push	r29
     bec:	ec 01       	movw	r28, r24
     bee:	04 2f       	mov	r16, r20
     bf0:	1a 8d       	ldd	r17, Y+26	; 0x1a
     bf2:	4c 8d       	ldd	r20, Y+28	; 0x1c
     bf4:	41 11       	cpse	r20, r1
     bf6:	0c c0       	rjmp	.+24     	; 0xc10 <prvCopyDataToQueue+0x2c>
     bf8:	88 81       	ld	r24, Y
     bfa:	99 81       	ldd	r25, Y+1	; 0x01
     bfc:	89 2b       	or	r24, r25
     bfe:	09 f0       	breq	.+2      	; 0xc02 <prvCopyDataToQueue+0x1e>
     c00:	42 c0       	rjmp	.+132    	; 0xc86 <prvCopyDataToQueue+0xa2>
     c02:	8a 81       	ldd	r24, Y+2	; 0x02
     c04:	9b 81       	ldd	r25, Y+3	; 0x03
     c06:	0e 94 31 0c 	call	0x1862	; 0x1862 <xTaskPriorityDisinherit>
     c0a:	1b 82       	std	Y+3, r1	; 0x03
     c0c:	1a 82       	std	Y+2, r1	; 0x02
     c0e:	42 c0       	rjmp	.+132    	; 0xc94 <prvCopyDataToQueue+0xb0>
     c10:	01 11       	cpse	r16, r1
     c12:	17 c0       	rjmp	.+46     	; 0xc42 <prvCopyDataToQueue+0x5e>
     c14:	50 e0       	ldi	r21, 0x00	; 0
     c16:	8c 81       	ldd	r24, Y+4	; 0x04
     c18:	9d 81       	ldd	r25, Y+5	; 0x05
     c1a:	0e 94 b4 0d 	call	0x1b68	; 0x1b68 <memcpy>
     c1e:	2c 8d       	ldd	r18, Y+28	; 0x1c
     c20:	8c 81       	ldd	r24, Y+4	; 0x04
     c22:	9d 81       	ldd	r25, Y+5	; 0x05
     c24:	82 0f       	add	r24, r18
     c26:	91 1d       	adc	r25, r1
     c28:	9d 83       	std	Y+5, r25	; 0x05
     c2a:	8c 83       	std	Y+4, r24	; 0x04
     c2c:	2a 81       	ldd	r18, Y+2	; 0x02
     c2e:	3b 81       	ldd	r19, Y+3	; 0x03
     c30:	82 17       	cp	r24, r18
     c32:	93 07       	cpc	r25, r19
     c34:	50 f1       	brcs	.+84     	; 0xc8a <prvCopyDataToQueue+0xa6>
     c36:	88 81       	ld	r24, Y
     c38:	99 81       	ldd	r25, Y+1	; 0x01
     c3a:	9d 83       	std	Y+5, r25	; 0x05
     c3c:	8c 83       	std	Y+4, r24	; 0x04
     c3e:	80 e0       	ldi	r24, 0x00	; 0
     c40:	29 c0       	rjmp	.+82     	; 0xc94 <prvCopyDataToQueue+0xb0>
     c42:	50 e0       	ldi	r21, 0x00	; 0
     c44:	8e 81       	ldd	r24, Y+6	; 0x06
     c46:	9f 81       	ldd	r25, Y+7	; 0x07
     c48:	0e 94 b4 0d 	call	0x1b68	; 0x1b68 <memcpy>
     c4c:	8c 8d       	ldd	r24, Y+28	; 0x1c
     c4e:	90 e0       	ldi	r25, 0x00	; 0
     c50:	91 95       	neg	r25
     c52:	81 95       	neg	r24
     c54:	91 09       	sbc	r25, r1
     c56:	2e 81       	ldd	r18, Y+6	; 0x06
     c58:	3f 81       	ldd	r19, Y+7	; 0x07
     c5a:	28 0f       	add	r18, r24
     c5c:	39 1f       	adc	r19, r25
     c5e:	3f 83       	std	Y+7, r19	; 0x07
     c60:	2e 83       	std	Y+6, r18	; 0x06
     c62:	48 81       	ld	r20, Y
     c64:	59 81       	ldd	r21, Y+1	; 0x01
     c66:	24 17       	cp	r18, r20
     c68:	35 07       	cpc	r19, r21
     c6a:	30 f4       	brcc	.+12     	; 0xc78 <prvCopyDataToQueue+0x94>
     c6c:	2a 81       	ldd	r18, Y+2	; 0x02
     c6e:	3b 81       	ldd	r19, Y+3	; 0x03
     c70:	82 0f       	add	r24, r18
     c72:	93 1f       	adc	r25, r19
     c74:	9f 83       	std	Y+7, r25	; 0x07
     c76:	8e 83       	std	Y+6, r24	; 0x06
     c78:	02 30       	cpi	r16, 0x02	; 2
     c7a:	49 f4       	brne	.+18     	; 0xc8e <prvCopyDataToQueue+0xaa>
     c7c:	11 23       	and	r17, r17
     c7e:	49 f0       	breq	.+18     	; 0xc92 <prvCopyDataToQueue+0xae>
     c80:	11 50       	subi	r17, 0x01	; 1
     c82:	80 e0       	ldi	r24, 0x00	; 0
     c84:	07 c0       	rjmp	.+14     	; 0xc94 <prvCopyDataToQueue+0xb0>
     c86:	80 e0       	ldi	r24, 0x00	; 0
     c88:	05 c0       	rjmp	.+10     	; 0xc94 <prvCopyDataToQueue+0xb0>
     c8a:	80 e0       	ldi	r24, 0x00	; 0
     c8c:	03 c0       	rjmp	.+6      	; 0xc94 <prvCopyDataToQueue+0xb0>
     c8e:	80 e0       	ldi	r24, 0x00	; 0
     c90:	01 c0       	rjmp	.+2      	; 0xc94 <prvCopyDataToQueue+0xb0>
     c92:	80 e0       	ldi	r24, 0x00	; 0
     c94:	1f 5f       	subi	r17, 0xFF	; 255
     c96:	1a 8f       	std	Y+26, r17	; 0x1a
     c98:	df 91       	pop	r29
     c9a:	cf 91       	pop	r28
     c9c:	1f 91       	pop	r17
     c9e:	0f 91       	pop	r16
     ca0:	08 95       	ret

00000ca2 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
     ca2:	ef 92       	push	r14
     ca4:	ff 92       	push	r15
     ca6:	0f 93       	push	r16
     ca8:	1f 93       	push	r17
     caa:	cf 93       	push	r28
     cac:	8c 01       	movw	r16, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
     cae:	0f b6       	in	r0, 0x3f	; 63
     cb0:	f8 94       	cli
     cb2:	0f 92       	push	r0
	{
		int8_t cTxLock = pxQueue->cTxLock;
     cb4:	fc 01       	movw	r30, r24
     cb6:	c6 8d       	ldd	r28, Z+30	; 0x1e

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
     cb8:	1c 16       	cp	r1, r28
     cba:	ac f4       	brge	.+42     	; 0xce6 <prvUnlockQueue+0x44>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     cbc:	81 89       	ldd	r24, Z+17	; 0x11
     cbe:	81 11       	cpse	r24, r1
     cc0:	06 c0       	rjmp	.+12     	; 0xcce <prvUnlockQueue+0x2c>
     cc2:	11 c0       	rjmp	.+34     	; 0xce6 <prvUnlockQueue+0x44>
     cc4:	f8 01       	movw	r30, r16
     cc6:	81 89       	ldd	r24, Z+17	; 0x11
     cc8:	81 11       	cpse	r24, r1
     cca:	05 c0       	rjmp	.+10     	; 0xcd6 <prvUnlockQueue+0x34>
     ccc:	0c c0       	rjmp	.+24     	; 0xce6 <prvUnlockQueue+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     cce:	78 01       	movw	r14, r16
     cd0:	f1 e1       	ldi	r31, 0x11	; 17
     cd2:	ef 0e       	add	r14, r31
     cd4:	f1 1c       	adc	r15, r1
     cd6:	c7 01       	movw	r24, r14
     cd8:	0e 94 a8 0b 	call	0x1750	; 0x1750 <xTaskRemoveFromEventList>
     cdc:	81 11       	cpse	r24, r1
					{
						/* The task waiting has a higher priority so record that
						a context switch is required. */
						vTaskMissedYield();
     cde:	0e 94 2d 0c 	call	0x185a	; 0x185a <vTaskMissedYield>
     ce2:	c1 50       	subi	r28, 0x01	; 1
	taskENTER_CRITICAL();
	{
		int8_t cTxLock = pxQueue->cTxLock;

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
     ce4:	79 f7       	brne	.-34     	; 0xcc4 <prvUnlockQueue+0x22>
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
		}

		pxQueue->cTxLock = queueUNLOCKED;
     ce6:	8f ef       	ldi	r24, 0xFF	; 255
     ce8:	f8 01       	movw	r30, r16
     cea:	86 8f       	std	Z+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
     cec:	0f 90       	pop	r0
     cee:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
     cf0:	0f b6       	in	r0, 0x3f	; 63
     cf2:	f8 94       	cli
     cf4:	0f 92       	push	r0
	{
		int8_t cRxLock = pxQueue->cRxLock;
     cf6:	c5 8d       	ldd	r28, Z+29	; 0x1d

		while( cRxLock > queueLOCKED_UNMODIFIED )
     cf8:	1c 16       	cp	r1, r28
     cfa:	ac f4       	brge	.+42     	; 0xd26 <prvUnlockQueue+0x84>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     cfc:	80 85       	ldd	r24, Z+8	; 0x08
     cfe:	81 11       	cpse	r24, r1
     d00:	06 c0       	rjmp	.+12     	; 0xd0e <prvUnlockQueue+0x6c>
     d02:	11 c0       	rjmp	.+34     	; 0xd26 <prvUnlockQueue+0x84>
     d04:	f8 01       	movw	r30, r16
     d06:	80 85       	ldd	r24, Z+8	; 0x08
     d08:	81 11       	cpse	r24, r1
     d0a:	05 c0       	rjmp	.+10     	; 0xd16 <prvUnlockQueue+0x74>
     d0c:	0c c0       	rjmp	.+24     	; 0xd26 <prvUnlockQueue+0x84>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     d0e:	78 01       	movw	r14, r16
     d10:	f8 e0       	ldi	r31, 0x08	; 8
     d12:	ef 0e       	add	r14, r31
     d14:	f1 1c       	adc	r15, r1
     d16:	c7 01       	movw	r24, r14
     d18:	0e 94 a8 0b 	call	0x1750	; 0x1750 <xTaskRemoveFromEventList>
     d1c:	81 11       	cpse	r24, r1
				{
					vTaskMissedYield();
     d1e:	0e 94 2d 0c 	call	0x185a	; 0x185a <vTaskMissedYield>
     d22:	c1 50       	subi	r28, 0x01	; 1
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		int8_t cRxLock = pxQueue->cRxLock;

		while( cRxLock > queueLOCKED_UNMODIFIED )
     d24:	79 f7       	brne	.-34     	; 0xd04 <prvUnlockQueue+0x62>
			{
				break;
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
     d26:	8f ef       	ldi	r24, 0xFF	; 255
     d28:	f8 01       	movw	r30, r16
     d2a:	85 8f       	std	Z+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
     d2c:	0f 90       	pop	r0
     d2e:	0f be       	out	0x3f, r0	; 63
}
     d30:	cf 91       	pop	r28
     d32:	1f 91       	pop	r17
     d34:	0f 91       	pop	r16
     d36:	ff 90       	pop	r15
     d38:	ef 90       	pop	r14
     d3a:	08 95       	ret

00000d3c <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
     d3c:	cf 93       	push	r28
     d3e:	df 93       	push	r29
     d40:	ec 01       	movw	r28, r24
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
     d42:	0f b6       	in	r0, 0x3f	; 63
     d44:	f8 94       	cli
     d46:	0f 92       	push	r0
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
     d48:	48 81       	ld	r20, Y
     d4a:	59 81       	ldd	r21, Y+1	; 0x01
     d4c:	2c 8d       	ldd	r18, Y+28	; 0x1c
     d4e:	30 e0       	ldi	r19, 0x00	; 0
     d50:	7b 8d       	ldd	r23, Y+27	; 0x1b
     d52:	72 9f       	mul	r23, r18
     d54:	c0 01       	movw	r24, r0
     d56:	73 9f       	mul	r23, r19
     d58:	90 0d       	add	r25, r0
     d5a:	11 24       	eor	r1, r1
     d5c:	fa 01       	movw	r30, r20
     d5e:	e8 0f       	add	r30, r24
     d60:	f9 1f       	adc	r31, r25
     d62:	fb 83       	std	Y+3, r31	; 0x03
     d64:	ea 83       	std	Y+2, r30	; 0x02
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
     d66:	1a 8e       	std	Y+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
     d68:	5d 83       	std	Y+5, r21	; 0x05
     d6a:	4c 83       	std	Y+4, r20	; 0x04
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
     d6c:	82 1b       	sub	r24, r18
     d6e:	93 0b       	sbc	r25, r19
     d70:	84 0f       	add	r24, r20
     d72:	95 1f       	adc	r25, r21
     d74:	9f 83       	std	Y+7, r25	; 0x07
     d76:	8e 83       	std	Y+6, r24	; 0x06
		pxQueue->cRxLock = queueUNLOCKED;
     d78:	8f ef       	ldi	r24, 0xFF	; 255
     d7a:	8d 8f       	std	Y+29, r24	; 0x1d
		pxQueue->cTxLock = queueUNLOCKED;
     d7c:	8e 8f       	std	Y+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
     d7e:	61 11       	cpse	r22, r1
     d80:	0c c0       	rjmp	.+24     	; 0xd9a <xQueueGenericReset+0x5e>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     d82:	88 85       	ldd	r24, Y+8	; 0x08
     d84:	88 23       	and	r24, r24
     d86:	89 f0       	breq	.+34     	; 0xdaa <xQueueGenericReset+0x6e>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     d88:	ce 01       	movw	r24, r28
     d8a:	08 96       	adiw	r24, 0x08	; 8
     d8c:	0e 94 a8 0b 	call	0x1750	; 0x1750 <xTaskRemoveFromEventList>
     d90:	88 23       	and	r24, r24
     d92:	59 f0       	breq	.+22     	; 0xdaa <xQueueGenericReset+0x6e>
				{
					queueYIELD_IF_USING_PREEMPTION();
     d94:	0e 94 3b 03 	call	0x676	; 0x676 <vPortYield>
     d98:	08 c0       	rjmp	.+16     	; 0xdaa <xQueueGenericReset+0x6e>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
     d9a:	ce 01       	movw	r24, r28
     d9c:	08 96       	adiw	r24, 0x08	; 8
     d9e:	0e 94 0b 02 	call	0x416	; 0x416 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
     da2:	ce 01       	movw	r24, r28
     da4:	41 96       	adiw	r24, 0x11	; 17
     da6:	0e 94 0b 02 	call	0x416	; 0x416 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
     daa:	0f 90       	pop	r0
     dac:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
}
     dae:	81 e0       	ldi	r24, 0x01	; 1
     db0:	df 91       	pop	r29
     db2:	cf 91       	pop	r28
     db4:	08 95       	ret

00000db6 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
	{
     db6:	ff 92       	push	r15
     db8:	0f 93       	push	r16
     dba:	1f 93       	push	r17
     dbc:	cf 93       	push	r28
     dbe:	df 93       	push	r29
     dc0:	08 2f       	mov	r16, r24
     dc2:	16 2f       	mov	r17, r22
     dc4:	f4 2e       	mov	r15, r20
	size_t xQueueSizeInBytes;
	uint8_t *pucQueueStorage;

		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

		if( uxItemSize == ( UBaseType_t ) 0 )
     dc6:	66 23       	and	r22, r22
     dc8:	c9 f0       	breq	.+50     	; 0xdfc <xQueueGenericCreate+0x46>
			/* Allocate enough space to hold the maximum number of items that
			can be in the queue at any time. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
		}

		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
     dca:	86 9f       	mul	r24, r22
     dcc:	c0 01       	movw	r24, r0
     dce:	11 24       	eor	r1, r1
     dd0:	81 96       	adiw	r24, 0x21	; 33
     dd2:	0e 94 f3 03 	call	0x7e6	; 0x7e6 <pvPortMalloc>
     dd6:	ec 01       	movw	r28, r24

		if( pxNewQueue != NULL )
     dd8:	00 97       	sbiw	r24, 0x00	; 0
     dda:	49 f4       	brne	.+18     	; 0xdee <xQueueGenericCreate+0x38>
     ddc:	16 c0       	rjmp	.+44     	; 0xe0a <xQueueGenericCreate+0x54>
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
	}

	/* Initialise the queue members as described where the queue type is
	defined. */
	pxNewQueue->uxLength = uxQueueLength;
     dde:	0b 8f       	std	Y+27, r16	; 0x1b
	pxNewQueue->uxItemSize = uxItemSize;
     de0:	1c 8f       	std	Y+28, r17	; 0x1c
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
     de2:	61 e0       	ldi	r22, 0x01	; 1
     de4:	ce 01       	movw	r24, r28
     de6:	0e 94 9e 06 	call	0xd3c	; 0xd3c <xQueueGenericReset>

	#if ( configUSE_TRACE_FACILITY == 1 )
	{
		pxNewQueue->ucQueueType = ucQueueType;
     dea:	f8 a2       	std	Y+32, r15	; 0x20
     dec:	0e c0       	rjmp	.+28     	; 0xe0a <xQueueGenericCreate+0x54>
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
	}
	else
	{
		/* Set the head to the start of the queue storage area. */
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
     dee:	81 96       	adiw	r24, 0x21	; 33
     df0:	99 83       	std	Y+1, r25	; 0x01
     df2:	88 83       	st	Y, r24
     df4:	f4 cf       	rjmp	.-24     	; 0xdde <xQueueGenericCreate+0x28>
	{
		/* No RAM was allocated for the queue storage area, but PC head cannot
		be set to NULL because NULL is used as a key to say the queue is used as
		a mutex.  Therefore just set pcHead to point to the queue as a benign
		value that is known to be within the memory map. */
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
     df6:	d9 83       	std	Y+1, r29	; 0x01
     df8:	c8 83       	st	Y, r28
     dfa:	f1 cf       	rjmp	.-30     	; 0xdde <xQueueGenericCreate+0x28>
			/* Allocate enough space to hold the maximum number of items that
			can be in the queue at any time. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
		}

		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
     dfc:	81 e2       	ldi	r24, 0x21	; 33
     dfe:	90 e0       	ldi	r25, 0x00	; 0
     e00:	0e 94 f3 03 	call	0x7e6	; 0x7e6 <pvPortMalloc>
     e04:	ec 01       	movw	r28, r24

		if( pxNewQueue != NULL )
     e06:	89 2b       	or	r24, r25
     e08:	b1 f7       	brne	.-20     	; 0xdf6 <xQueueGenericCreate+0x40>

			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
		}

		return pxNewQueue;
	}
     e0a:	ce 01       	movw	r24, r28
     e0c:	df 91       	pop	r29
     e0e:	cf 91       	pop	r28
     e10:	1f 91       	pop	r17
     e12:	0f 91       	pop	r16
     e14:	ff 90       	pop	r15
     e16:	08 95       	ret

00000e18 <xQueueGenericSend>:

#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
     e18:	9f 92       	push	r9
     e1a:	af 92       	push	r10
     e1c:	bf 92       	push	r11
     e1e:	cf 92       	push	r12
     e20:	df 92       	push	r13
     e22:	ef 92       	push	r14
     e24:	ff 92       	push	r15
     e26:	0f 93       	push	r16
     e28:	1f 93       	push	r17
     e2a:	cf 93       	push	r28
     e2c:	df 93       	push	r29
     e2e:	00 d0       	rcall	.+0      	; 0xe30 <xQueueGenericSend+0x18>
     e30:	00 d0       	rcall	.+0      	; 0xe32 <xQueueGenericSend+0x1a>
     e32:	1f 92       	push	r1
     e34:	cd b7       	in	r28, 0x3d	; 61
     e36:	de b7       	in	r29, 0x3e	; 62
     e38:	8c 01       	movw	r16, r24
     e3a:	6b 01       	movw	r12, r22
     e3c:	5d 83       	std	Y+5, r21	; 0x05
     e3e:	4c 83       	std	Y+4, r20	; 0x04
     e40:	a2 2e       	mov	r10, r18
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
     e42:	b1 2c       	mov	r11, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
     e44:	99 24       	eor	r9, r9
     e46:	93 94       	inc	r9
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
     e48:	7c 01       	movw	r14, r24
     e4a:	88 e0       	ldi	r24, 0x08	; 8
     e4c:	e8 0e       	add	r14, r24
     e4e:	f1 1c       	adc	r15, r1
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
     e50:	0f b6       	in	r0, 0x3f	; 63
     e52:	f8 94       	cli
     e54:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
     e56:	f8 01       	movw	r30, r16
     e58:	92 8d       	ldd	r25, Z+26	; 0x1a
     e5a:	83 8d       	ldd	r24, Z+27	; 0x1b
     e5c:	98 17       	cp	r25, r24
     e5e:	18 f0       	brcs	.+6      	; 0xe66 <xQueueGenericSend+0x4e>
     e60:	f2 e0       	ldi	r31, 0x02	; 2
     e62:	af 12       	cpse	r10, r31
     e64:	19 c0       	rjmp	.+50     	; 0xe98 <xQueueGenericSend+0x80>
			{
				traceQUEUE_SEND( pxQueue );
				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
     e66:	4a 2d       	mov	r20, r10
     e68:	b6 01       	movw	r22, r12
     e6a:	c8 01       	movw	r24, r16
     e6c:	0e 94 f2 05 	call	0xbe4	; 0xbe4 <prvCopyDataToQueue>
				}
				#else /* configUSE_QUEUE_SETS */
				{
					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     e70:	f8 01       	movw	r30, r16
     e72:	91 89       	ldd	r25, Z+17	; 0x11
     e74:	99 23       	and	r25, r25
     e76:	49 f0       	breq	.+18     	; 0xe8a <xQueueGenericSend+0x72>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     e78:	c8 01       	movw	r24, r16
     e7a:	41 96       	adiw	r24, 0x11	; 17
     e7c:	0e 94 a8 0b 	call	0x1750	; 0x1750 <xTaskRemoveFromEventList>
     e80:	88 23       	and	r24, r24
     e82:	31 f0       	breq	.+12     	; 0xe90 <xQueueGenericSend+0x78>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
     e84:	0e 94 3b 03 	call	0x676	; 0x676 <vPortYield>
     e88:	03 c0       	rjmp	.+6      	; 0xe90 <xQueueGenericSend+0x78>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
     e8a:	81 11       	cpse	r24, r1
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
     e8c:	0e 94 3b 03 	call	0x676	; 0x676 <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
     e90:	0f 90       	pop	r0
     e92:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
     e94:	81 e0       	ldi	r24, 0x01	; 1
     e96:	50 c0       	rjmp	.+160    	; 0xf38 <xQueueGenericSend+0x120>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
     e98:	8c 81       	ldd	r24, Y+4	; 0x04
     e9a:	9d 81       	ldd	r25, Y+5	; 0x05
     e9c:	89 2b       	or	r24, r25
     e9e:	21 f4       	brne	.+8      	; 0xea8 <xQueueGenericSend+0x90>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
     ea0:	0f 90       	pop	r0
     ea2:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
     ea4:	80 e0       	ldi	r24, 0x00	; 0
     ea6:	48 c0       	rjmp	.+144    	; 0xf38 <xQueueGenericSend+0x120>
				}
				else if( xEntryTimeSet == pdFALSE )
     ea8:	b1 10       	cpse	r11, r1
     eaa:	05 c0       	rjmp	.+10     	; 0xeb6 <xQueueGenericSend+0x9e>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
     eac:	ce 01       	movw	r24, r28
     eae:	01 96       	adiw	r24, 0x01	; 1
     eb0:	0e 94 f0 0b 	call	0x17e0	; 0x17e0 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
     eb4:	b9 2c       	mov	r11, r9
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
     eb6:	0f 90       	pop	r0
     eb8:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
     eba:	0e 94 a3 09 	call	0x1346	; 0x1346 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
     ebe:	0f b6       	in	r0, 0x3f	; 63
     ec0:	f8 94       	cli
     ec2:	0f 92       	push	r0
     ec4:	f8 01       	movw	r30, r16
     ec6:	85 8d       	ldd	r24, Z+29	; 0x1d
     ec8:	8f 3f       	cpi	r24, 0xFF	; 255
     eca:	09 f4       	brne	.+2      	; 0xece <xQueueGenericSend+0xb6>
     ecc:	15 8e       	std	Z+29, r1	; 0x1d
     ece:	f8 01       	movw	r30, r16
     ed0:	86 8d       	ldd	r24, Z+30	; 0x1e
     ed2:	8f 3f       	cpi	r24, 0xFF	; 255
     ed4:	09 f4       	brne	.+2      	; 0xed8 <xQueueGenericSend+0xc0>
     ed6:	16 8e       	std	Z+30, r1	; 0x1e
     ed8:	0f 90       	pop	r0
     eda:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
     edc:	be 01       	movw	r22, r28
     ede:	6c 5f       	subi	r22, 0xFC	; 252
     ee0:	7f 4f       	sbci	r23, 0xFF	; 255
     ee2:	ce 01       	movw	r24, r28
     ee4:	01 96       	adiw	r24, 0x01	; 1
     ee6:	0e 94 fb 0b 	call	0x17f6	; 0x17f6 <xTaskCheckForTimeOut>
     eea:	81 11       	cpse	r24, r1
     eec:	1f c0       	rjmp	.+62     	; 0xf2c <xQueueGenericSend+0x114>

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
     eee:	0f b6       	in	r0, 0x3f	; 63
     ef0:	f8 94       	cli
     ef2:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
     ef4:	f8 01       	movw	r30, r16
     ef6:	92 8d       	ldd	r25, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
     ef8:	0f 90       	pop	r0
     efa:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
     efc:	83 8d       	ldd	r24, Z+27	; 0x1b
     efe:	98 13       	cpse	r25, r24
     f00:	0f c0       	rjmp	.+30     	; 0xf20 <xQueueGenericSend+0x108>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
     f02:	6c 81       	ldd	r22, Y+4	; 0x04
     f04:	7d 81       	ldd	r23, Y+5	; 0x05
     f06:	c7 01       	movw	r24, r14
     f08:	0e 94 96 0b 	call	0x172c	; 0x172c <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
     f0c:	c8 01       	movw	r24, r16
     f0e:	0e 94 51 06 	call	0xca2	; 0xca2 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
     f12:	0e 94 64 0a 	call	0x14c8	; 0x14c8 <xTaskResumeAll>
     f16:	81 11       	cpse	r24, r1
     f18:	9b cf       	rjmp	.-202    	; 0xe50 <xQueueGenericSend+0x38>
				{
					portYIELD_WITHIN_API();
     f1a:	0e 94 3b 03 	call	0x676	; 0x676 <vPortYield>
     f1e:	98 cf       	rjmp	.-208    	; 0xe50 <xQueueGenericSend+0x38>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
     f20:	c8 01       	movw	r24, r16
     f22:	0e 94 51 06 	call	0xca2	; 0xca2 <prvUnlockQueue>
				( void ) xTaskResumeAll();
     f26:	0e 94 64 0a 	call	0x14c8	; 0x14c8 <xTaskResumeAll>
     f2a:	92 cf       	rjmp	.-220    	; 0xe50 <xQueueGenericSend+0x38>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
     f2c:	c8 01       	movw	r24, r16
     f2e:	0e 94 51 06 	call	0xca2	; 0xca2 <prvUnlockQueue>
			( void ) xTaskResumeAll();
     f32:	0e 94 64 0a 	call	0x14c8	; 0x14c8 <xTaskResumeAll>

			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
     f36:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
     f38:	0f 90       	pop	r0
     f3a:	0f 90       	pop	r0
     f3c:	0f 90       	pop	r0
     f3e:	0f 90       	pop	r0
     f40:	0f 90       	pop	r0
     f42:	df 91       	pop	r29
     f44:	cf 91       	pop	r28
     f46:	1f 91       	pop	r17
     f48:	0f 91       	pop	r16
     f4a:	ff 90       	pop	r15
     f4c:	ef 90       	pop	r14
     f4e:	df 90       	pop	r13
     f50:	cf 90       	pop	r12
     f52:	bf 90       	pop	r11
     f54:	af 90       	pop	r10
     f56:	9f 90       	pop	r9
     f58:	08 95       	ret

00000f5a <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if( ( configUSE_MUTEXES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )

	QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
	{
     f5a:	cf 93       	push	r28
     f5c:	df 93       	push	r29
	Queue_t *pxNewQueue;
	const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;

		pxNewQueue = ( Queue_t * ) xQueueGenericCreate( uxMutexLength, uxMutexSize, ucQueueType );
     f5e:	48 2f       	mov	r20, r24
     f60:	60 e0       	ldi	r22, 0x00	; 0
     f62:	81 e0       	ldi	r24, 0x01	; 1
     f64:	0e 94 db 06 	call	0xdb6	; 0xdb6 <xQueueGenericCreate>
     f68:	ec 01       	movw	r28, r24

#if( configUSE_MUTEXES == 1 )

	static void prvInitialiseMutex( Queue_t *pxNewQueue )
	{
		if( pxNewQueue != NULL )
     f6a:	00 97       	sbiw	r24, 0x00	; 0
     f6c:	61 f0       	breq	.+24     	; 0xf86 <xQueueCreateMutex+0x2c>
		{
			/* The queue create function will set all the queue structure members
			correctly for a generic queue, but this function is creating a
			mutex.  Overwrite those members that need to be set differently -
			in particular the information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
     f6e:	1b 82       	std	Y+3, r1	; 0x03
     f70:	1a 82       	std	Y+2, r1	; 0x02
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
     f72:	19 82       	std	Y+1, r1	; 0x01
     f74:	18 82       	st	Y, r1

			/* In case this is a recursive mutex. */
			pxNewQueue->u.uxRecursiveCallCount = 0;
     f76:	1e 82       	std	Y+6, r1	; 0x06

			traceCREATE_MUTEX( pxNewQueue );

			/* Start with the semaphore in the expected state. */
			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
     f78:	20 e0       	ldi	r18, 0x00	; 0
     f7a:	40 e0       	ldi	r20, 0x00	; 0
     f7c:	50 e0       	ldi	r21, 0x00	; 0
     f7e:	60 e0       	ldi	r22, 0x00	; 0
     f80:	70 e0       	ldi	r23, 0x00	; 0
     f82:	0e 94 0c 07 	call	0xe18	; 0xe18 <xQueueGenericSend>

		pxNewQueue = ( Queue_t * ) xQueueGenericCreate( uxMutexLength, uxMutexSize, ucQueueType );
		prvInitialiseMutex( pxNewQueue );

		return pxNewQueue;
	}
     f86:	ce 01       	movw	r24, r28
     f88:	df 91       	pop	r29
     f8a:	cf 91       	pop	r28
     f8c:	08 95       	ret

00000f8e <xQueueGenericSendFromISR>:
	}
}
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
     f8e:	ef 92       	push	r14
     f90:	ff 92       	push	r15
     f92:	0f 93       	push	r16
     f94:	1f 93       	push	r17
     f96:	cf 93       	push	r28
     f98:	df 93       	push	r29
     f9a:	8a 01       	movw	r16, r20
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
     f9c:	fc 01       	movw	r30, r24
     f9e:	52 8d       	ldd	r21, Z+26	; 0x1a
     fa0:	33 8d       	ldd	r19, Z+27	; 0x1b
     fa2:	53 17       	cp	r21, r19
     fa4:	10 f0       	brcs	.+4      	; 0xfaa <xQueueGenericSendFromISR+0x1c>
     fa6:	22 30       	cpi	r18, 0x02	; 2
     fa8:	f1 f4       	brne	.+60     	; 0xfe6 <xQueueGenericSendFromISR+0x58>
     faa:	42 2f       	mov	r20, r18
     fac:	78 01       	movw	r14, r16
     fae:	ec 01       	movw	r28, r24
		{
			const int8_t cTxLock = pxQueue->cTxLock;
     fb0:	1e 8d       	ldd	r17, Y+30	; 0x1e
			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
			in a task disinheriting a priority and prvCopyDataToQueue() can be
			called here even though the disinherit function does not check if
			the scheduler is suspended before accessing the ready lists. */
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
     fb2:	0e 94 f2 05 	call	0xbe4	; 0xbe4 <prvCopyDataToQueue>

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
     fb6:	1f 3f       	cpi	r17, 0xFF	; 255
     fb8:	81 f4       	brne	.+32     	; 0xfda <xQueueGenericSendFromISR+0x4c>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     fba:	89 89       	ldd	r24, Y+17	; 0x11
     fbc:	88 23       	and	r24, r24
     fbe:	a9 f0       	breq	.+42     	; 0xfea <xQueueGenericSendFromISR+0x5c>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     fc0:	ce 01       	movw	r24, r28
     fc2:	41 96       	adiw	r24, 0x11	; 17
     fc4:	0e 94 a8 0b 	call	0x1750	; 0x1750 <xTaskRemoveFromEventList>
     fc8:	88 23       	and	r24, r24
     fca:	89 f0       	breq	.+34     	; 0xfee <xQueueGenericSendFromISR+0x60>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
     fcc:	e1 14       	cp	r14, r1
     fce:	f1 04       	cpc	r15, r1
     fd0:	81 f0       	breq	.+32     	; 0xff2 <xQueueGenericSendFromISR+0x64>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
     fd2:	81 e0       	ldi	r24, 0x01	; 1
     fd4:	f7 01       	movw	r30, r14
     fd6:	80 83       	st	Z, r24
     fd8:	0d c0       	rjmp	.+26     	; 0xff4 <xQueueGenericSendFromISR+0x66>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
     fda:	ff 24       	eor	r15, r15
     fdc:	f3 94       	inc	r15
     fde:	f1 0e       	add	r15, r17
     fe0:	fe 8e       	std	Y+30, r15	; 0x1e
			}

			xReturn = pdPASS;
     fe2:	81 e0       	ldi	r24, 0x01	; 1
     fe4:	07 c0       	rjmp	.+14     	; 0xff4 <xQueueGenericSendFromISR+0x66>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
     fe6:	80 e0       	ldi	r24, 0x00	; 0
     fe8:	05 c0       	rjmp	.+10     	; 0xff4 <xQueueGenericSendFromISR+0x66>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
			}

			xReturn = pdPASS;
     fea:	81 e0       	ldi	r24, 0x01	; 1
     fec:	03 c0       	rjmp	.+6      	; 0xff4 <xQueueGenericSendFromISR+0x66>
     fee:	81 e0       	ldi	r24, 0x01	; 1
     ff0:	01 c0       	rjmp	.+2      	; 0xff4 <xQueueGenericSendFromISR+0x66>
     ff2:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
     ff4:	df 91       	pop	r29
     ff6:	cf 91       	pop	r28
     ff8:	1f 91       	pop	r17
     ffa:	0f 91       	pop	r16
     ffc:	ff 90       	pop	r15
     ffe:	ef 90       	pop	r14
    1000:	08 95       	ret

00001002 <prvResetNextTaskUnblockTime>:
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    1002:	e0 91 ac 05 	lds	r30, 0x05AC	; 0x8005ac <pxDelayedTaskList>
    1006:	f0 91 ad 05 	lds	r31, 0x05AD	; 0x8005ad <pxDelayedTaskList+0x1>
    100a:	80 81       	ld	r24, Z
    100c:	81 11       	cpse	r24, r1
    100e:	07 c0       	rjmp	.+14     	; 0x101e <prvResetNextTaskUnblockTime+0x1c>
    1010:	8f ef       	ldi	r24, 0xFF	; 255
    1012:	9f ef       	ldi	r25, 0xFF	; 255
    1014:	90 93 8d 05 	sts	0x058D, r25	; 0x80058d <xNextTaskUnblockTime+0x1>
    1018:	80 93 8c 05 	sts	0x058C, r24	; 0x80058c <xNextTaskUnblockTime>
    101c:	08 95       	ret
    101e:	e0 91 ac 05 	lds	r30, 0x05AC	; 0x8005ac <pxDelayedTaskList>
    1022:	f0 91 ad 05 	lds	r31, 0x05AD	; 0x8005ad <pxDelayedTaskList+0x1>
    1026:	05 80       	ldd	r0, Z+5	; 0x05
    1028:	f6 81       	ldd	r31, Z+6	; 0x06
    102a:	e0 2d       	mov	r30, r0
    102c:	06 80       	ldd	r0, Z+6	; 0x06
    102e:	f7 81       	ldd	r31, Z+7	; 0x07
    1030:	e0 2d       	mov	r30, r0
    1032:	82 81       	ldd	r24, Z+2	; 0x02
    1034:	93 81       	ldd	r25, Z+3	; 0x03
    1036:	90 93 8d 05 	sts	0x058D, r25	; 0x80058d <xNextTaskUnblockTime+0x1>
    103a:	80 93 8c 05 	sts	0x058C, r24	; 0x80058c <xNextTaskUnblockTime>
    103e:	08 95       	ret

00001040 <prvAddCurrentTaskToDelayedList>:
    1040:	0f 93       	push	r16
    1042:	1f 93       	push	r17
    1044:	cf 93       	push	r28
    1046:	df 93       	push	r29
    1048:	ec 01       	movw	r28, r24
    104a:	00 91 94 05 	lds	r16, 0x0594	; 0x800594 <xTickCount>
    104e:	10 91 95 05 	lds	r17, 0x0595	; 0x800595 <xTickCount+0x1>
    1052:	80 91 e4 05 	lds	r24, 0x05E4	; 0x8005e4 <pxCurrentTCB>
    1056:	90 91 e5 05 	lds	r25, 0x05E5	; 0x8005e5 <pxCurrentTCB+0x1>
    105a:	02 96       	adiw	r24, 0x02	; 2
    105c:	0e 94 6f 02 	call	0x4de	; 0x4de <uxListRemove>
    1060:	c0 0f       	add	r28, r16
    1062:	d1 1f       	adc	r29, r17
    1064:	e0 91 e4 05 	lds	r30, 0x05E4	; 0x8005e4 <pxCurrentTCB>
    1068:	f0 91 e5 05 	lds	r31, 0x05E5	; 0x8005e5 <pxCurrentTCB+0x1>
    106c:	d3 83       	std	Z+3, r29	; 0x03
    106e:	c2 83       	std	Z+2, r28	; 0x02
    1070:	c0 17       	cp	r28, r16
    1072:	d1 07       	cpc	r29, r17
    1074:	68 f4       	brcc	.+26     	; 0x1090 <prvAddCurrentTaskToDelayedList+0x50>
    1076:	60 91 e4 05 	lds	r22, 0x05E4	; 0x8005e4 <pxCurrentTCB>
    107a:	70 91 e5 05 	lds	r23, 0x05E5	; 0x8005e5 <pxCurrentTCB+0x1>
    107e:	80 91 aa 05 	lds	r24, 0x05AA	; 0x8005aa <pxOverflowDelayedTaskList>
    1082:	90 91 ab 05 	lds	r25, 0x05AB	; 0x8005ab <pxOverflowDelayedTaskList+0x1>
    1086:	6e 5f       	subi	r22, 0xFE	; 254
    1088:	7f 4f       	sbci	r23, 0xFF	; 255
    108a:	0e 94 3e 02 	call	0x47c	; 0x47c <vListInsert>
    108e:	17 c0       	rjmp	.+46     	; 0x10be <prvAddCurrentTaskToDelayedList+0x7e>
    1090:	60 91 e4 05 	lds	r22, 0x05E4	; 0x8005e4 <pxCurrentTCB>
    1094:	70 91 e5 05 	lds	r23, 0x05E5	; 0x8005e5 <pxCurrentTCB+0x1>
    1098:	80 91 ac 05 	lds	r24, 0x05AC	; 0x8005ac <pxDelayedTaskList>
    109c:	90 91 ad 05 	lds	r25, 0x05AD	; 0x8005ad <pxDelayedTaskList+0x1>
    10a0:	6e 5f       	subi	r22, 0xFE	; 254
    10a2:	7f 4f       	sbci	r23, 0xFF	; 255
    10a4:	0e 94 3e 02 	call	0x47c	; 0x47c <vListInsert>
    10a8:	80 91 8c 05 	lds	r24, 0x058C	; 0x80058c <xNextTaskUnblockTime>
    10ac:	90 91 8d 05 	lds	r25, 0x058D	; 0x80058d <xNextTaskUnblockTime+0x1>
    10b0:	c8 17       	cp	r28, r24
    10b2:	d9 07       	cpc	r29, r25
    10b4:	20 f4       	brcc	.+8      	; 0x10be <prvAddCurrentTaskToDelayedList+0x7e>
    10b6:	d0 93 8d 05 	sts	0x058D, r29	; 0x80058d <xNextTaskUnblockTime+0x1>
    10ba:	c0 93 8c 05 	sts	0x058C, r28	; 0x80058c <xNextTaskUnblockTime>
    10be:	df 91       	pop	r29
    10c0:	cf 91       	pop	r28
    10c2:	1f 91       	pop	r17
    10c4:	0f 91       	pop	r16
    10c6:	08 95       	ret

000010c8 <xTaskCreate>:
    10c8:	4f 92       	push	r4
    10ca:	5f 92       	push	r5
    10cc:	6f 92       	push	r6
    10ce:	7f 92       	push	r7
    10d0:	8f 92       	push	r8
    10d2:	9f 92       	push	r9
    10d4:	af 92       	push	r10
    10d6:	bf 92       	push	r11
    10d8:	cf 92       	push	r12
    10da:	df 92       	push	r13
    10dc:	ef 92       	push	r14
    10de:	ff 92       	push	r15
    10e0:	0f 93       	push	r16
    10e2:	cf 93       	push	r28
    10e4:	df 93       	push	r29
    10e6:	4c 01       	movw	r8, r24
    10e8:	6b 01       	movw	r12, r22
    10ea:	5a 01       	movw	r10, r20
    10ec:	29 01       	movw	r4, r18
    10ee:	ca 01       	movw	r24, r20
    10f0:	0e 94 f3 03 	call	0x7e6	; 0x7e6 <pvPortMalloc>
    10f4:	3c 01       	movw	r6, r24
    10f6:	89 2b       	or	r24, r25
    10f8:	09 f4       	brne	.+2      	; 0x10fc <xTaskCreate+0x34>
    10fa:	ea c0       	rjmp	.+468    	; 0x12d0 <xTaskCreate+0x208>
    10fc:	8c e2       	ldi	r24, 0x2C	; 44
    10fe:	90 e0       	ldi	r25, 0x00	; 0
    1100:	0e 94 f3 03 	call	0x7e6	; 0x7e6 <pvPortMalloc>
    1104:	ec 01       	movw	r28, r24
    1106:	89 2b       	or	r24, r25
    1108:	b1 f0       	breq	.+44     	; 0x1136 <xTaskCreate+0x6e>
    110a:	78 8e       	std	Y+24, r7	; 0x18
    110c:	6f 8a       	std	Y+23, r6	; 0x17
    110e:	a5 01       	movw	r20, r10
    1110:	65 ea       	ldi	r22, 0xA5	; 165
    1112:	70 e0       	ldi	r23, 0x00	; 0
    1114:	c3 01       	movw	r24, r6
    1116:	0e 94 bd 0d 	call	0x1b7a	; 0x1b7a <memset>
    111a:	81 e0       	ldi	r24, 0x01	; 1
    111c:	a8 1a       	sub	r10, r24
    111e:	b1 08       	sbc	r11, r1
    1120:	8f 89       	ldd	r24, Y+23	; 0x17
    1122:	98 8d       	ldd	r25, Y+24	; 0x18
    1124:	a8 0e       	add	r10, r24
    1126:	b9 1e       	adc	r11, r25
    1128:	d6 01       	movw	r26, r12
    112a:	8c 91       	ld	r24, X
    112c:	89 8f       	std	Y+25, r24	; 0x19
    112e:	8c 91       	ld	r24, X
    1130:	81 11       	cpse	r24, r1
    1132:	05 c0       	rjmp	.+10     	; 0x113e <xTaskCreate+0x76>
    1134:	18 c0       	rjmp	.+48     	; 0x1166 <xTaskCreate+0x9e>
    1136:	c3 01       	movw	r24, r6
    1138:	0e 94 28 04 	call	0x850	; 0x850 <vPortFree>
    113c:	c9 c0       	rjmp	.+402    	; 0x12d0 <xTaskCreate+0x208>
    113e:	ae 01       	movw	r20, r28
    1140:	46 5e       	subi	r20, 0xE6	; 230
    1142:	5f 4f       	sbci	r21, 0xFF	; 255
    1144:	f6 01       	movw	r30, r12
    1146:	31 96       	adiw	r30, 0x01	; 1
    1148:	b8 e0       	ldi	r27, 0x08	; 8
    114a:	cb 0e       	add	r12, r27
    114c:	d1 1c       	adc	r13, r1
    114e:	cf 01       	movw	r24, r30
    1150:	21 91       	ld	r18, Z+
    1152:	da 01       	movw	r26, r20
    1154:	2d 93       	st	X+, r18
    1156:	ad 01       	movw	r20, r26
    1158:	dc 01       	movw	r26, r24
    115a:	8c 91       	ld	r24, X
    115c:	88 23       	and	r24, r24
    115e:	19 f0       	breq	.+6      	; 0x1166 <xTaskCreate+0x9e>
    1160:	ec 15       	cp	r30, r12
    1162:	fd 05       	cpc	r31, r13
    1164:	a1 f7       	brne	.-24     	; 0x114e <xTaskCreate+0x86>
    1166:	18 a2       	std	Y+32, r1	; 0x20
    1168:	04 30       	cpi	r16, 0x04	; 4
    116a:	08 f0       	brcs	.+2      	; 0x116e <xTaskCreate+0xa6>
    116c:	03 e0       	ldi	r16, 0x03	; 3
    116e:	0e 8b       	std	Y+22, r16	; 0x16
    1170:	0b a3       	std	Y+35, r16	; 0x23
    1172:	1c a2       	std	Y+36, r1	; 0x24
    1174:	6e 01       	movw	r12, r28
    1176:	b2 e0       	ldi	r27, 0x02	; 2
    1178:	cb 0e       	add	r12, r27
    117a:	d1 1c       	adc	r13, r1
    117c:	c6 01       	movw	r24, r12
    117e:	0e 94 19 02 	call	0x432	; 0x432 <vListInitialiseItem>
    1182:	ce 01       	movw	r24, r28
    1184:	0c 96       	adiw	r24, 0x0c	; 12
    1186:	0e 94 19 02 	call	0x432	; 0x432 <vListInitialiseItem>
    118a:	d9 87       	std	Y+9, r29	; 0x09
    118c:	c8 87       	std	Y+8, r28	; 0x08
    118e:	84 e0       	ldi	r24, 0x04	; 4
    1190:	90 e0       	ldi	r25, 0x00	; 0
    1192:	80 1b       	sub	r24, r16
    1194:	91 09       	sbc	r25, r1
    1196:	9d 87       	std	Y+13, r25	; 0x0d
    1198:	8c 87       	std	Y+12, r24	; 0x0c
    119a:	db 8b       	std	Y+19, r29	; 0x13
    119c:	ca 8b       	std	Y+18, r28	; 0x12
    119e:	1e a2       	std	Y+38, r1	; 0x26
    11a0:	1d a2       	std	Y+37, r1	; 0x25
    11a2:	1f a2       	std	Y+39, r1	; 0x27
    11a4:	18 a6       	std	Y+40, r1	; 0x28
    11a6:	19 a6       	std	Y+41, r1	; 0x29
    11a8:	1a a6       	std	Y+42, r1	; 0x2a
    11aa:	1b a6       	std	Y+43, r1	; 0x2b
    11ac:	a2 01       	movw	r20, r4
    11ae:	b4 01       	movw	r22, r8
    11b0:	c5 01       	movw	r24, r10
    11b2:	0e 94 95 02 	call	0x52a	; 0x52a <pxPortInitialiseStack>
    11b6:	99 83       	std	Y+1, r25	; 0x01
    11b8:	88 83       	st	Y, r24
    11ba:	e1 14       	cp	r14, r1
    11bc:	f1 04       	cpc	r15, r1
    11be:	19 f0       	breq	.+6      	; 0x11c6 <xTaskCreate+0xfe>
    11c0:	f7 01       	movw	r30, r14
    11c2:	d1 83       	std	Z+1, r29	; 0x01
    11c4:	c0 83       	st	Z, r28
    11c6:	0f b6       	in	r0, 0x3f	; 63
    11c8:	f8 94       	cli
    11ca:	0f 92       	push	r0
    11cc:	80 91 96 05 	lds	r24, 0x0596	; 0x800596 <uxCurrentNumberOfTasks>
    11d0:	8f 5f       	subi	r24, 0xFF	; 255
    11d2:	80 93 96 05 	sts	0x0596, r24	; 0x800596 <uxCurrentNumberOfTasks>
    11d6:	80 91 e4 05 	lds	r24, 0x05E4	; 0x8005e4 <pxCurrentTCB>
    11da:	90 91 e5 05 	lds	r25, 0x05E5	; 0x8005e5 <pxCurrentTCB+0x1>
    11de:	89 2b       	or	r24, r25
    11e0:	a9 f5       	brne	.+106    	; 0x124c <xTaskCreate+0x184>
    11e2:	d0 93 e5 05 	sts	0x05E5, r29	; 0x8005e5 <pxCurrentTCB+0x1>
    11e6:	c0 93 e4 05 	sts	0x05E4, r28	; 0x8005e4 <pxCurrentTCB>
    11ea:	80 91 96 05 	lds	r24, 0x0596	; 0x800596 <uxCurrentNumberOfTasks>
    11ee:	81 30       	cpi	r24, 0x01	; 1
    11f0:	e9 f5       	brne	.+122    	; 0x126c <xTaskCreate+0x1a4>
    11f2:	80 ec       	ldi	r24, 0xC0	; 192
    11f4:	95 e0       	ldi	r25, 0x05	; 5
    11f6:	0e 94 0b 02 	call	0x416	; 0x416 <vListInitialise>
    11fa:	89 ec       	ldi	r24, 0xC9	; 201
    11fc:	95 e0       	ldi	r25, 0x05	; 5
    11fe:	0e 94 0b 02 	call	0x416	; 0x416 <vListInitialise>
    1202:	82 ed       	ldi	r24, 0xD2	; 210
    1204:	95 e0       	ldi	r25, 0x05	; 5
    1206:	0e 94 0b 02 	call	0x416	; 0x416 <vListInitialise>
    120a:	8b ed       	ldi	r24, 0xDB	; 219
    120c:	95 e0       	ldi	r25, 0x05	; 5
    120e:	0e 94 0b 02 	call	0x416	; 0x416 <vListInitialise>
    1212:	87 eb       	ldi	r24, 0xB7	; 183
    1214:	95 e0       	ldi	r25, 0x05	; 5
    1216:	0e 94 0b 02 	call	0x416	; 0x416 <vListInitialise>
    121a:	8e ea       	ldi	r24, 0xAE	; 174
    121c:	95 e0       	ldi	r25, 0x05	; 5
    121e:	0e 94 0b 02 	call	0x416	; 0x416 <vListInitialise>
    1222:	81 ea       	ldi	r24, 0xA1	; 161
    1224:	95 e0       	ldi	r25, 0x05	; 5
    1226:	0e 94 0b 02 	call	0x416	; 0x416 <vListInitialise>
    122a:	88 e9       	ldi	r24, 0x98	; 152
    122c:	95 e0       	ldi	r25, 0x05	; 5
    122e:	0e 94 0b 02 	call	0x416	; 0x416 <vListInitialise>
    1232:	87 eb       	ldi	r24, 0xB7	; 183
    1234:	95 e0       	ldi	r25, 0x05	; 5
    1236:	90 93 ad 05 	sts	0x05AD, r25	; 0x8005ad <pxDelayedTaskList+0x1>
    123a:	80 93 ac 05 	sts	0x05AC, r24	; 0x8005ac <pxDelayedTaskList>
    123e:	8e ea       	ldi	r24, 0xAE	; 174
    1240:	95 e0       	ldi	r25, 0x05	; 5
    1242:	90 93 ab 05 	sts	0x05AB, r25	; 0x8005ab <pxOverflowDelayedTaskList+0x1>
    1246:	80 93 aa 05 	sts	0x05AA, r24	; 0x8005aa <pxOverflowDelayedTaskList>
    124a:	10 c0       	rjmp	.+32     	; 0x126c <xTaskCreate+0x1a4>
    124c:	80 91 92 05 	lds	r24, 0x0592	; 0x800592 <xSchedulerRunning>
    1250:	81 11       	cpse	r24, r1
    1252:	0c c0       	rjmp	.+24     	; 0x126c <xTaskCreate+0x1a4>
    1254:	e0 91 e4 05 	lds	r30, 0x05E4	; 0x8005e4 <pxCurrentTCB>
    1258:	f0 91 e5 05 	lds	r31, 0x05E5	; 0x8005e5 <pxCurrentTCB+0x1>
    125c:	96 89       	ldd	r25, Z+22	; 0x16
    125e:	8e 89       	ldd	r24, Y+22	; 0x16
    1260:	89 17       	cp	r24, r25
    1262:	20 f0       	brcs	.+8      	; 0x126c <xTaskCreate+0x1a4>
    1264:	d0 93 e5 05 	sts	0x05E5, r29	; 0x8005e5 <pxCurrentTCB+0x1>
    1268:	c0 93 e4 05 	sts	0x05E4, r28	; 0x8005e4 <pxCurrentTCB>
    126c:	80 91 8e 05 	lds	r24, 0x058E	; 0x80058e <uxTaskNumber>
    1270:	8f 5f       	subi	r24, 0xFF	; 255
    1272:	80 93 8e 05 	sts	0x058E, r24	; 0x80058e <uxTaskNumber>
    1276:	89 a3       	std	Y+33, r24	; 0x21
    1278:	8e 89       	ldd	r24, Y+22	; 0x16
    127a:	90 91 93 05 	lds	r25, 0x0593	; 0x800593 <uxTopReadyPriority>
    127e:	98 17       	cp	r25, r24
    1280:	10 f4       	brcc	.+4      	; 0x1286 <xTaskCreate+0x1be>
    1282:	80 93 93 05 	sts	0x0593, r24	; 0x800593 <uxTopReadyPriority>
    1286:	90 e0       	ldi	r25, 0x00	; 0
    1288:	9c 01       	movw	r18, r24
    128a:	22 0f       	add	r18, r18
    128c:	33 1f       	adc	r19, r19
    128e:	22 0f       	add	r18, r18
    1290:	33 1f       	adc	r19, r19
    1292:	22 0f       	add	r18, r18
    1294:	33 1f       	adc	r19, r19
    1296:	82 0f       	add	r24, r18
    1298:	93 1f       	adc	r25, r19
    129a:	b6 01       	movw	r22, r12
    129c:	80 54       	subi	r24, 0x40	; 64
    129e:	9a 4f       	sbci	r25, 0xFA	; 250
    12a0:	0e 94 1d 02 	call	0x43a	; 0x43a <vListInsertEnd>
    12a4:	0f 90       	pop	r0
    12a6:	0f be       	out	0x3f, r0	; 63
    12a8:	80 91 92 05 	lds	r24, 0x0592	; 0x800592 <xSchedulerRunning>
    12ac:	88 23       	and	r24, r24
    12ae:	61 f0       	breq	.+24     	; 0x12c8 <xTaskCreate+0x200>
    12b0:	e0 91 e4 05 	lds	r30, 0x05E4	; 0x8005e4 <pxCurrentTCB>
    12b4:	f0 91 e5 05 	lds	r31, 0x05E5	; 0x8005e5 <pxCurrentTCB+0x1>
    12b8:	96 89       	ldd	r25, Z+22	; 0x16
    12ba:	8e 89       	ldd	r24, Y+22	; 0x16
    12bc:	98 17       	cp	r25, r24
    12be:	30 f4       	brcc	.+12     	; 0x12cc <xTaskCreate+0x204>
    12c0:	0e 94 3b 03 	call	0x676	; 0x676 <vPortYield>
    12c4:	81 e0       	ldi	r24, 0x01	; 1
    12c6:	05 c0       	rjmp	.+10     	; 0x12d2 <xTaskCreate+0x20a>
    12c8:	81 e0       	ldi	r24, 0x01	; 1
    12ca:	03 c0       	rjmp	.+6      	; 0x12d2 <xTaskCreate+0x20a>
    12cc:	81 e0       	ldi	r24, 0x01	; 1
    12ce:	01 c0       	rjmp	.+2      	; 0x12d2 <xTaskCreate+0x20a>
    12d0:	8f ef       	ldi	r24, 0xFF	; 255
    12d2:	df 91       	pop	r29
    12d4:	cf 91       	pop	r28
    12d6:	0f 91       	pop	r16
    12d8:	ff 90       	pop	r15
    12da:	ef 90       	pop	r14
    12dc:	df 90       	pop	r13
    12de:	cf 90       	pop	r12
    12e0:	bf 90       	pop	r11
    12e2:	af 90       	pop	r10
    12e4:	9f 90       	pop	r9
    12e6:	8f 90       	pop	r8
    12e8:	7f 90       	pop	r7
    12ea:	6f 90       	pop	r6
    12ec:	5f 90       	pop	r5
    12ee:	4f 90       	pop	r4
    12f0:	08 95       	ret

000012f2 <vTaskStartScheduler>:
    12f2:	ef 92       	push	r14
    12f4:	ff 92       	push	r15
    12f6:	0f 93       	push	r16
    12f8:	0f 2e       	mov	r0, r31
    12fa:	fa e8       	ldi	r31, 0x8A	; 138
    12fc:	ef 2e       	mov	r14, r31
    12fe:	f5 e0       	ldi	r31, 0x05	; 5
    1300:	ff 2e       	mov	r15, r31
    1302:	f0 2d       	mov	r31, r0
    1304:	00 e0       	ldi	r16, 0x00	; 0
    1306:	20 e0       	ldi	r18, 0x00	; 0
    1308:	30 e0       	ldi	r19, 0x00	; 0
    130a:	45 e5       	ldi	r20, 0x55	; 85
    130c:	50 e0       	ldi	r21, 0x00	; 0
    130e:	68 e2       	ldi	r22, 0x28	; 40
    1310:	71 e0       	ldi	r23, 0x01	; 1
    1312:	83 ee       	ldi	r24, 0xE3	; 227
    1314:	9a e0       	ldi	r25, 0x0A	; 10
    1316:	0e 94 64 08 	call	0x10c8	; 0x10c8 <xTaskCreate>
    131a:	81 30       	cpi	r24, 0x01	; 1
    131c:	81 f4       	brne	.+32     	; 0x133e <vTaskStartScheduler+0x4c>
    131e:	f8 94       	cli
    1320:	8f ef       	ldi	r24, 0xFF	; 255
    1322:	9f ef       	ldi	r25, 0xFF	; 255
    1324:	90 93 8d 05 	sts	0x058D, r25	; 0x80058d <xNextTaskUnblockTime+0x1>
    1328:	80 93 8c 05 	sts	0x058C, r24	; 0x80058c <xNextTaskUnblockTime>
    132c:	81 e0       	ldi	r24, 0x01	; 1
    132e:	80 93 92 05 	sts	0x0592, r24	; 0x800592 <xSchedulerRunning>
    1332:	10 92 95 05 	sts	0x0595, r1	; 0x800595 <xTickCount+0x1>
    1336:	10 92 94 05 	sts	0x0594, r1	; 0x800594 <xTickCount>
    133a:	0e 94 01 03 	call	0x602	; 0x602 <xPortStartScheduler>
    133e:	0f 91       	pop	r16
    1340:	ff 90       	pop	r15
    1342:	ef 90       	pop	r14
    1344:	08 95       	ret

00001346 <vTaskSuspendAll>:
    1346:	80 91 89 05 	lds	r24, 0x0589	; 0x800589 <uxSchedulerSuspended>
    134a:	8f 5f       	subi	r24, 0xFF	; 255
    134c:	80 93 89 05 	sts	0x0589, r24	; 0x800589 <uxSchedulerSuspended>
    1350:	08 95       	ret

00001352 <xTaskIncrementTick>:
    1352:	cf 92       	push	r12
    1354:	df 92       	push	r13
    1356:	ef 92       	push	r14
    1358:	ff 92       	push	r15
    135a:	0f 93       	push	r16
    135c:	1f 93       	push	r17
    135e:	cf 93       	push	r28
    1360:	df 93       	push	r29
    1362:	80 91 89 05 	lds	r24, 0x0589	; 0x800589 <uxSchedulerSuspended>
    1366:	81 11       	cpse	r24, r1
    1368:	99 c0       	rjmp	.+306    	; 0x149c <xTaskIncrementTick+0x14a>
    136a:	e0 90 94 05 	lds	r14, 0x0594	; 0x800594 <xTickCount>
    136e:	f0 90 95 05 	lds	r15, 0x0595	; 0x800595 <xTickCount+0x1>
    1372:	8f ef       	ldi	r24, 0xFF	; 255
    1374:	e8 1a       	sub	r14, r24
    1376:	f8 0a       	sbc	r15, r24
    1378:	f0 92 95 05 	sts	0x0595, r15	; 0x800595 <xTickCount+0x1>
    137c:	e0 92 94 05 	sts	0x0594, r14	; 0x800594 <xTickCount>
    1380:	e1 14       	cp	r14, r1
    1382:	f1 04       	cpc	r15, r1
    1384:	b9 f4       	brne	.+46     	; 0x13b4 <xTaskIncrementTick+0x62>
    1386:	80 91 ac 05 	lds	r24, 0x05AC	; 0x8005ac <pxDelayedTaskList>
    138a:	90 91 ad 05 	lds	r25, 0x05AD	; 0x8005ad <pxDelayedTaskList+0x1>
    138e:	20 91 aa 05 	lds	r18, 0x05AA	; 0x8005aa <pxOverflowDelayedTaskList>
    1392:	30 91 ab 05 	lds	r19, 0x05AB	; 0x8005ab <pxOverflowDelayedTaskList+0x1>
    1396:	30 93 ad 05 	sts	0x05AD, r19	; 0x8005ad <pxDelayedTaskList+0x1>
    139a:	20 93 ac 05 	sts	0x05AC, r18	; 0x8005ac <pxDelayedTaskList>
    139e:	90 93 ab 05 	sts	0x05AB, r25	; 0x8005ab <pxOverflowDelayedTaskList+0x1>
    13a2:	80 93 aa 05 	sts	0x05AA, r24	; 0x8005aa <pxOverflowDelayedTaskList>
    13a6:	80 91 8f 05 	lds	r24, 0x058F	; 0x80058f <xNumOfOverflows>
    13aa:	8f 5f       	subi	r24, 0xFF	; 255
    13ac:	80 93 8f 05 	sts	0x058F, r24	; 0x80058f <xNumOfOverflows>
    13b0:	0e 94 01 08 	call	0x1002	; 0x1002 <prvResetNextTaskUnblockTime>
    13b4:	80 91 8c 05 	lds	r24, 0x058C	; 0x80058c <xNextTaskUnblockTime>
    13b8:	90 91 8d 05 	lds	r25, 0x058D	; 0x80058d <xNextTaskUnblockTime+0x1>
    13bc:	e8 16       	cp	r14, r24
    13be:	f9 06       	cpc	r15, r25
    13c0:	10 f4       	brcc	.+4      	; 0x13c6 <xTaskIncrementTick+0x74>
    13c2:	d1 2c       	mov	r13, r1
    13c4:	53 c0       	rjmp	.+166    	; 0x146c <xTaskIncrementTick+0x11a>
    13c6:	d1 2c       	mov	r13, r1
    13c8:	cc 24       	eor	r12, r12
    13ca:	c3 94       	inc	r12
    13cc:	e0 91 ac 05 	lds	r30, 0x05AC	; 0x8005ac <pxDelayedTaskList>
    13d0:	f0 91 ad 05 	lds	r31, 0x05AD	; 0x8005ad <pxDelayedTaskList+0x1>
    13d4:	80 81       	ld	r24, Z
    13d6:	81 11       	cpse	r24, r1
    13d8:	07 c0       	rjmp	.+14     	; 0x13e8 <xTaskIncrementTick+0x96>
    13da:	8f ef       	ldi	r24, 0xFF	; 255
    13dc:	9f ef       	ldi	r25, 0xFF	; 255
    13de:	90 93 8d 05 	sts	0x058D, r25	; 0x80058d <xNextTaskUnblockTime+0x1>
    13e2:	80 93 8c 05 	sts	0x058C, r24	; 0x80058c <xNextTaskUnblockTime>
    13e6:	42 c0       	rjmp	.+132    	; 0x146c <xTaskIncrementTick+0x11a>
    13e8:	e0 91 ac 05 	lds	r30, 0x05AC	; 0x8005ac <pxDelayedTaskList>
    13ec:	f0 91 ad 05 	lds	r31, 0x05AD	; 0x8005ad <pxDelayedTaskList+0x1>
    13f0:	05 80       	ldd	r0, Z+5	; 0x05
    13f2:	f6 81       	ldd	r31, Z+6	; 0x06
    13f4:	e0 2d       	mov	r30, r0
    13f6:	c6 81       	ldd	r28, Z+6	; 0x06
    13f8:	d7 81       	ldd	r29, Z+7	; 0x07
    13fa:	8a 81       	ldd	r24, Y+2	; 0x02
    13fc:	9b 81       	ldd	r25, Y+3	; 0x03
    13fe:	e8 16       	cp	r14, r24
    1400:	f9 06       	cpc	r15, r25
    1402:	28 f4       	brcc	.+10     	; 0x140e <xTaskIncrementTick+0xbc>
    1404:	90 93 8d 05 	sts	0x058D, r25	; 0x80058d <xNextTaskUnblockTime+0x1>
    1408:	80 93 8c 05 	sts	0x058C, r24	; 0x80058c <xNextTaskUnblockTime>
    140c:	2f c0       	rjmp	.+94     	; 0x146c <xTaskIncrementTick+0x11a>
    140e:	8e 01       	movw	r16, r28
    1410:	0e 5f       	subi	r16, 0xFE	; 254
    1412:	1f 4f       	sbci	r17, 0xFF	; 255
    1414:	c8 01       	movw	r24, r16
    1416:	0e 94 6f 02 	call	0x4de	; 0x4de <uxListRemove>
    141a:	8c 89       	ldd	r24, Y+20	; 0x14
    141c:	9d 89       	ldd	r25, Y+21	; 0x15
    141e:	89 2b       	or	r24, r25
    1420:	21 f0       	breq	.+8      	; 0x142a <xTaskIncrementTick+0xd8>
    1422:	ce 01       	movw	r24, r28
    1424:	0c 96       	adiw	r24, 0x0c	; 12
    1426:	0e 94 6f 02 	call	0x4de	; 0x4de <uxListRemove>
    142a:	8e 89       	ldd	r24, Y+22	; 0x16
    142c:	90 91 93 05 	lds	r25, 0x0593	; 0x800593 <uxTopReadyPriority>
    1430:	98 17       	cp	r25, r24
    1432:	10 f4       	brcc	.+4      	; 0x1438 <xTaskIncrementTick+0xe6>
    1434:	80 93 93 05 	sts	0x0593, r24	; 0x800593 <uxTopReadyPriority>
    1438:	90 e0       	ldi	r25, 0x00	; 0
    143a:	9c 01       	movw	r18, r24
    143c:	22 0f       	add	r18, r18
    143e:	33 1f       	adc	r19, r19
    1440:	22 0f       	add	r18, r18
    1442:	33 1f       	adc	r19, r19
    1444:	22 0f       	add	r18, r18
    1446:	33 1f       	adc	r19, r19
    1448:	82 0f       	add	r24, r18
    144a:	93 1f       	adc	r25, r19
    144c:	b8 01       	movw	r22, r16
    144e:	80 54       	subi	r24, 0x40	; 64
    1450:	9a 4f       	sbci	r25, 0xFA	; 250
    1452:	0e 94 1d 02 	call	0x43a	; 0x43a <vListInsertEnd>
    1456:	e0 91 e4 05 	lds	r30, 0x05E4	; 0x8005e4 <pxCurrentTCB>
    145a:	f0 91 e5 05 	lds	r31, 0x05E5	; 0x8005e5 <pxCurrentTCB+0x1>
    145e:	9e 89       	ldd	r25, Y+22	; 0x16
    1460:	86 89       	ldd	r24, Z+22	; 0x16
    1462:	98 17       	cp	r25, r24
    1464:	08 f4       	brcc	.+2      	; 0x1468 <xTaskIncrementTick+0x116>
    1466:	b2 cf       	rjmp	.-156    	; 0x13cc <xTaskIncrementTick+0x7a>
    1468:	dc 2c       	mov	r13, r12
    146a:	b0 cf       	rjmp	.-160    	; 0x13cc <xTaskIncrementTick+0x7a>
    146c:	e0 91 e4 05 	lds	r30, 0x05E4	; 0x8005e4 <pxCurrentTCB>
    1470:	f0 91 e5 05 	lds	r31, 0x05E5	; 0x8005e5 <pxCurrentTCB+0x1>
    1474:	86 89       	ldd	r24, Z+22	; 0x16
    1476:	90 e0       	ldi	r25, 0x00	; 0
    1478:	fc 01       	movw	r30, r24
    147a:	ee 0f       	add	r30, r30
    147c:	ff 1f       	adc	r31, r31
    147e:	ee 0f       	add	r30, r30
    1480:	ff 1f       	adc	r31, r31
    1482:	ee 0f       	add	r30, r30
    1484:	ff 1f       	adc	r31, r31
    1486:	8e 0f       	add	r24, r30
    1488:	9f 1f       	adc	r25, r31
    148a:	fc 01       	movw	r30, r24
    148c:	e0 54       	subi	r30, 0x40	; 64
    148e:	fa 4f       	sbci	r31, 0xFA	; 250
    1490:	80 81       	ld	r24, Z
    1492:	82 30       	cpi	r24, 0x02	; 2
    1494:	48 f0       	brcs	.+18     	; 0x14a8 <xTaskIncrementTick+0x156>
    1496:	dd 24       	eor	r13, r13
    1498:	d3 94       	inc	r13
    149a:	06 c0       	rjmp	.+12     	; 0x14a8 <xTaskIncrementTick+0x156>
    149c:	80 91 91 05 	lds	r24, 0x0591	; 0x800591 <uxPendedTicks>
    14a0:	8f 5f       	subi	r24, 0xFF	; 255
    14a2:	80 93 91 05 	sts	0x0591, r24	; 0x800591 <uxPendedTicks>
    14a6:	d1 2c       	mov	r13, r1
    14a8:	80 91 90 05 	lds	r24, 0x0590	; 0x800590 <xYieldPending>
    14ac:	88 23       	and	r24, r24
    14ae:	11 f0       	breq	.+4      	; 0x14b4 <xTaskIncrementTick+0x162>
    14b0:	dd 24       	eor	r13, r13
    14b2:	d3 94       	inc	r13
    14b4:	8d 2d       	mov	r24, r13
    14b6:	df 91       	pop	r29
    14b8:	cf 91       	pop	r28
    14ba:	1f 91       	pop	r17
    14bc:	0f 91       	pop	r16
    14be:	ff 90       	pop	r15
    14c0:	ef 90       	pop	r14
    14c2:	df 90       	pop	r13
    14c4:	cf 90       	pop	r12
    14c6:	08 95       	ret

000014c8 <xTaskResumeAll>:
    14c8:	df 92       	push	r13
    14ca:	ef 92       	push	r14
    14cc:	ff 92       	push	r15
    14ce:	0f 93       	push	r16
    14d0:	1f 93       	push	r17
    14d2:	cf 93       	push	r28
    14d4:	df 93       	push	r29
    14d6:	0f b6       	in	r0, 0x3f	; 63
    14d8:	f8 94       	cli
    14da:	0f 92       	push	r0
    14dc:	80 91 89 05 	lds	r24, 0x0589	; 0x800589 <uxSchedulerSuspended>
    14e0:	81 50       	subi	r24, 0x01	; 1
    14e2:	80 93 89 05 	sts	0x0589, r24	; 0x800589 <uxSchedulerSuspended>
    14e6:	80 91 89 05 	lds	r24, 0x0589	; 0x800589 <uxSchedulerSuspended>
    14ea:	81 11       	cpse	r24, r1
    14ec:	5f c0       	rjmp	.+190    	; 0x15ac <xTaskResumeAll+0xe4>
    14ee:	80 91 96 05 	lds	r24, 0x0596	; 0x800596 <uxCurrentNumberOfTasks>
    14f2:	81 11       	cpse	r24, r1
    14f4:	33 c0       	rjmp	.+102    	; 0x155c <xTaskResumeAll+0x94>
    14f6:	5d c0       	rjmp	.+186    	; 0x15b2 <xTaskResumeAll+0xea>
    14f8:	d7 01       	movw	r26, r14
    14fa:	15 96       	adiw	r26, 0x05	; 5
    14fc:	ed 91       	ld	r30, X+
    14fe:	fc 91       	ld	r31, X
    1500:	16 97       	sbiw	r26, 0x06	; 6
    1502:	c6 81       	ldd	r28, Z+6	; 0x06
    1504:	d7 81       	ldd	r29, Z+7	; 0x07
    1506:	ce 01       	movw	r24, r28
    1508:	0c 96       	adiw	r24, 0x0c	; 12
    150a:	0e 94 6f 02 	call	0x4de	; 0x4de <uxListRemove>
    150e:	8e 01       	movw	r16, r28
    1510:	0e 5f       	subi	r16, 0xFE	; 254
    1512:	1f 4f       	sbci	r17, 0xFF	; 255
    1514:	c8 01       	movw	r24, r16
    1516:	0e 94 6f 02 	call	0x4de	; 0x4de <uxListRemove>
    151a:	8e 89       	ldd	r24, Y+22	; 0x16
    151c:	90 91 93 05 	lds	r25, 0x0593	; 0x800593 <uxTopReadyPriority>
    1520:	98 17       	cp	r25, r24
    1522:	10 f4       	brcc	.+4      	; 0x1528 <xTaskResumeAll+0x60>
    1524:	80 93 93 05 	sts	0x0593, r24	; 0x800593 <uxTopReadyPriority>
    1528:	90 e0       	ldi	r25, 0x00	; 0
    152a:	9c 01       	movw	r18, r24
    152c:	22 0f       	add	r18, r18
    152e:	33 1f       	adc	r19, r19
    1530:	22 0f       	add	r18, r18
    1532:	33 1f       	adc	r19, r19
    1534:	22 0f       	add	r18, r18
    1536:	33 1f       	adc	r19, r19
    1538:	82 0f       	add	r24, r18
    153a:	93 1f       	adc	r25, r19
    153c:	b8 01       	movw	r22, r16
    153e:	80 54       	subi	r24, 0x40	; 64
    1540:	9a 4f       	sbci	r25, 0xFA	; 250
    1542:	0e 94 1d 02 	call	0x43a	; 0x43a <vListInsertEnd>
    1546:	e0 91 e4 05 	lds	r30, 0x05E4	; 0x8005e4 <pxCurrentTCB>
    154a:	f0 91 e5 05 	lds	r31, 0x05E5	; 0x8005e5 <pxCurrentTCB+0x1>
    154e:	9e 89       	ldd	r25, Y+22	; 0x16
    1550:	86 89       	ldd	r24, Z+22	; 0x16
    1552:	98 17       	cp	r25, r24
    1554:	68 f0       	brcs	.+26     	; 0x1570 <xTaskResumeAll+0xa8>
    1556:	d0 92 90 05 	sts	0x0590, r13	; 0x800590 <xYieldPending>
    155a:	0a c0       	rjmp	.+20     	; 0x1570 <xTaskResumeAll+0xa8>
    155c:	c0 e0       	ldi	r28, 0x00	; 0
    155e:	d0 e0       	ldi	r29, 0x00	; 0
    1560:	0f 2e       	mov	r0, r31
    1562:	f1 ea       	ldi	r31, 0xA1	; 161
    1564:	ef 2e       	mov	r14, r31
    1566:	f5 e0       	ldi	r31, 0x05	; 5
    1568:	ff 2e       	mov	r15, r31
    156a:	f0 2d       	mov	r31, r0
    156c:	dd 24       	eor	r13, r13
    156e:	d3 94       	inc	r13
    1570:	f7 01       	movw	r30, r14
    1572:	80 81       	ld	r24, Z
    1574:	81 11       	cpse	r24, r1
    1576:	c0 cf       	rjmp	.-128    	; 0x14f8 <xTaskResumeAll+0x30>
    1578:	cd 2b       	or	r28, r29
    157a:	11 f0       	breq	.+4      	; 0x1580 <xTaskResumeAll+0xb8>
    157c:	0e 94 01 08 	call	0x1002	; 0x1002 <prvResetNextTaskUnblockTime>
    1580:	c0 91 91 05 	lds	r28, 0x0591	; 0x800591 <uxPendedTicks>
    1584:	cc 23       	and	r28, r28
    1586:	51 f0       	breq	.+20     	; 0x159c <xTaskResumeAll+0xd4>
    1588:	d1 e0       	ldi	r29, 0x01	; 1
    158a:	0e 94 a9 09 	call	0x1352	; 0x1352 <xTaskIncrementTick>
    158e:	81 11       	cpse	r24, r1
    1590:	d0 93 90 05 	sts	0x0590, r29	; 0x800590 <xYieldPending>
    1594:	c1 50       	subi	r28, 0x01	; 1
    1596:	c9 f7       	brne	.-14     	; 0x158a <xTaskResumeAll+0xc2>
    1598:	10 92 91 05 	sts	0x0591, r1	; 0x800591 <uxPendedTicks>
    159c:	80 91 90 05 	lds	r24, 0x0590	; 0x800590 <xYieldPending>
    15a0:	88 23       	and	r24, r24
    15a2:	31 f0       	breq	.+12     	; 0x15b0 <xTaskResumeAll+0xe8>
    15a4:	0e 94 3b 03 	call	0x676	; 0x676 <vPortYield>
    15a8:	81 e0       	ldi	r24, 0x01	; 1
    15aa:	03 c0       	rjmp	.+6      	; 0x15b2 <xTaskResumeAll+0xea>
    15ac:	80 e0       	ldi	r24, 0x00	; 0
    15ae:	01 c0       	rjmp	.+2      	; 0x15b2 <xTaskResumeAll+0xea>
    15b0:	80 e0       	ldi	r24, 0x00	; 0
    15b2:	0f 90       	pop	r0
    15b4:	0f be       	out	0x3f, r0	; 63
    15b6:	df 91       	pop	r29
    15b8:	cf 91       	pop	r28
    15ba:	1f 91       	pop	r17
    15bc:	0f 91       	pop	r16
    15be:	ff 90       	pop	r15
    15c0:	ef 90       	pop	r14
    15c2:	df 90       	pop	r13
    15c4:	08 95       	ret

000015c6 <prvIdleTask>:
    15c6:	08 e9       	ldi	r16, 0x98	; 152
    15c8:	15 e0       	ldi	r17, 0x05	; 5
    15ca:	0f 2e       	mov	r0, r31
    15cc:	f0 ec       	ldi	r31, 0xC0	; 192
    15ce:	ef 2e       	mov	r14, r31
    15d0:	f5 e0       	ldi	r31, 0x05	; 5
    15d2:	ff 2e       	mov	r15, r31
    15d4:	f0 2d       	mov	r31, r0
    15d6:	29 c0       	rjmp	.+82     	; 0x162a <prvIdleTask+0x64>
    15d8:	0e 94 a3 09 	call	0x1346	; 0x1346 <vTaskSuspendAll>
    15dc:	d8 01       	movw	r26, r16
    15de:	cc 91       	ld	r28, X
    15e0:	0e 94 64 0a 	call	0x14c8	; 0x14c8 <xTaskResumeAll>
    15e4:	cc 23       	and	r28, r28
    15e6:	09 f1       	breq	.+66     	; 0x162a <prvIdleTask+0x64>
    15e8:	0f b6       	in	r0, 0x3f	; 63
    15ea:	f8 94       	cli
    15ec:	0f 92       	push	r0
    15ee:	d8 01       	movw	r26, r16
    15f0:	15 96       	adiw	r26, 0x05	; 5
    15f2:	ed 91       	ld	r30, X+
    15f4:	fc 91       	ld	r31, X
    15f6:	16 97       	sbiw	r26, 0x06	; 6
    15f8:	c6 81       	ldd	r28, Z+6	; 0x06
    15fa:	d7 81       	ldd	r29, Z+7	; 0x07
    15fc:	ce 01       	movw	r24, r28
    15fe:	02 96       	adiw	r24, 0x02	; 2
    1600:	0e 94 6f 02 	call	0x4de	; 0x4de <uxListRemove>
    1604:	80 91 96 05 	lds	r24, 0x0596	; 0x800596 <uxCurrentNumberOfTasks>
    1608:	81 50       	subi	r24, 0x01	; 1
    160a:	80 93 96 05 	sts	0x0596, r24	; 0x800596 <uxCurrentNumberOfTasks>
    160e:	80 91 97 05 	lds	r24, 0x0597	; 0x800597 <uxDeletedTasksWaitingCleanUp>
    1612:	81 50       	subi	r24, 0x01	; 1
    1614:	80 93 97 05 	sts	0x0597, r24	; 0x800597 <uxDeletedTasksWaitingCleanUp>
    1618:	0f 90       	pop	r0
    161a:	0f be       	out	0x3f, r0	; 63
    161c:	8f 89       	ldd	r24, Y+23	; 0x17
    161e:	98 8d       	ldd	r25, Y+24	; 0x18
    1620:	0e 94 28 04 	call	0x850	; 0x850 <vPortFree>
    1624:	ce 01       	movw	r24, r28
    1626:	0e 94 28 04 	call	0x850	; 0x850 <vPortFree>
    162a:	80 91 97 05 	lds	r24, 0x0597	; 0x800597 <uxDeletedTasksWaitingCleanUp>
    162e:	81 11       	cpse	r24, r1
    1630:	d3 cf       	rjmp	.-90     	; 0x15d8 <prvIdleTask+0x12>
    1632:	f7 01       	movw	r30, r14
    1634:	80 81       	ld	r24, Z
    1636:	82 30       	cpi	r24, 0x02	; 2
    1638:	10 f0       	brcs	.+4      	; 0x163e <prvIdleTask+0x78>
    163a:	0e 94 3b 03 	call	0x676	; 0x676 <vPortYield>
    163e:	0e 94 e3 00 	call	0x1c6	; 0x1c6 <vApplicationIdleHook>
    1642:	f3 cf       	rjmp	.-26     	; 0x162a <prvIdleTask+0x64>

00001644 <vTaskSwitchContext>:
    1644:	80 91 89 05 	lds	r24, 0x0589	; 0x800589 <uxSchedulerSuspended>
    1648:	88 23       	and	r24, r24
    164a:	21 f0       	breq	.+8      	; 0x1654 <vTaskSwitchContext+0x10>
    164c:	81 e0       	ldi	r24, 0x01	; 1
    164e:	80 93 90 05 	sts	0x0590, r24	; 0x800590 <xYieldPending>
    1652:	08 95       	ret
    1654:	10 92 90 05 	sts	0x0590, r1	; 0x800590 <xYieldPending>
    1658:	e0 91 e4 05 	lds	r30, 0x05E4	; 0x8005e4 <pxCurrentTCB>
    165c:	f0 91 e5 05 	lds	r31, 0x05E5	; 0x8005e5 <pxCurrentTCB+0x1>
    1660:	85 a1       	ldd	r24, Z+37	; 0x25
    1662:	0e 94 c4 01 	call	0x388	; 0x388 <switch_out>
    1666:	20 91 93 05 	lds	r18, 0x0593	; 0x800593 <uxTopReadyPriority>
    166a:	82 2f       	mov	r24, r18
    166c:	90 e0       	ldi	r25, 0x00	; 0
    166e:	fc 01       	movw	r30, r24
    1670:	ee 0f       	add	r30, r30
    1672:	ff 1f       	adc	r31, r31
    1674:	ee 0f       	add	r30, r30
    1676:	ff 1f       	adc	r31, r31
    1678:	ee 0f       	add	r30, r30
    167a:	ff 1f       	adc	r31, r31
    167c:	e8 0f       	add	r30, r24
    167e:	f9 1f       	adc	r31, r25
    1680:	e0 54       	subi	r30, 0x40	; 64
    1682:	fa 4f       	sbci	r31, 0xFA	; 250
    1684:	30 81       	ld	r19, Z
    1686:	31 11       	cpse	r19, r1
    1688:	11 c0       	rjmp	.+34     	; 0x16ac <vTaskSwitchContext+0x68>
    168a:	21 50       	subi	r18, 0x01	; 1
    168c:	82 2f       	mov	r24, r18
    168e:	90 e0       	ldi	r25, 0x00	; 0
    1690:	fc 01       	movw	r30, r24
    1692:	ee 0f       	add	r30, r30
    1694:	ff 1f       	adc	r31, r31
    1696:	ee 0f       	add	r30, r30
    1698:	ff 1f       	adc	r31, r31
    169a:	ee 0f       	add	r30, r30
    169c:	ff 1f       	adc	r31, r31
    169e:	e8 0f       	add	r30, r24
    16a0:	f9 1f       	adc	r31, r25
    16a2:	e0 54       	subi	r30, 0x40	; 64
    16a4:	fa 4f       	sbci	r31, 0xFA	; 250
    16a6:	30 81       	ld	r19, Z
    16a8:	33 23       	and	r19, r19
    16aa:	79 f3       	breq	.-34     	; 0x168a <vTaskSwitchContext+0x46>
    16ac:	ac 01       	movw	r20, r24
    16ae:	44 0f       	add	r20, r20
    16b0:	55 1f       	adc	r21, r21
    16b2:	44 0f       	add	r20, r20
    16b4:	55 1f       	adc	r21, r21
    16b6:	44 0f       	add	r20, r20
    16b8:	55 1f       	adc	r21, r21
    16ba:	48 0f       	add	r20, r24
    16bc:	59 1f       	adc	r21, r25
    16be:	da 01       	movw	r26, r20
    16c0:	a0 54       	subi	r26, 0x40	; 64
    16c2:	ba 4f       	sbci	r27, 0xFA	; 250
    16c4:	11 96       	adiw	r26, 0x01	; 1
    16c6:	ed 91       	ld	r30, X+
    16c8:	fc 91       	ld	r31, X
    16ca:	12 97       	sbiw	r26, 0x02	; 2
    16cc:	02 80       	ldd	r0, Z+2	; 0x02
    16ce:	f3 81       	ldd	r31, Z+3	; 0x03
    16d0:	e0 2d       	mov	r30, r0
    16d2:	12 96       	adiw	r26, 0x02	; 2
    16d4:	fc 93       	st	X, r31
    16d6:	ee 93       	st	-X, r30
    16d8:	11 97       	sbiw	r26, 0x01	; 1
    16da:	4d 53       	subi	r20, 0x3D	; 61
    16dc:	5a 4f       	sbci	r21, 0xFA	; 250
    16de:	e4 17       	cp	r30, r20
    16e0:	f5 07       	cpc	r31, r21
    16e2:	29 f4       	brne	.+10     	; 0x16ee <vTaskSwitchContext+0xaa>
    16e4:	42 81       	ldd	r20, Z+2	; 0x02
    16e6:	53 81       	ldd	r21, Z+3	; 0x03
    16e8:	fd 01       	movw	r30, r26
    16ea:	52 83       	std	Z+2, r21	; 0x02
    16ec:	41 83       	std	Z+1, r20	; 0x01
    16ee:	fc 01       	movw	r30, r24
    16f0:	ee 0f       	add	r30, r30
    16f2:	ff 1f       	adc	r31, r31
    16f4:	ee 0f       	add	r30, r30
    16f6:	ff 1f       	adc	r31, r31
    16f8:	ee 0f       	add	r30, r30
    16fa:	ff 1f       	adc	r31, r31
    16fc:	8e 0f       	add	r24, r30
    16fe:	9f 1f       	adc	r25, r31
    1700:	fc 01       	movw	r30, r24
    1702:	e0 54       	subi	r30, 0x40	; 64
    1704:	fa 4f       	sbci	r31, 0xFA	; 250
    1706:	01 80       	ldd	r0, Z+1	; 0x01
    1708:	f2 81       	ldd	r31, Z+2	; 0x02
    170a:	e0 2d       	mov	r30, r0
    170c:	86 81       	ldd	r24, Z+6	; 0x06
    170e:	97 81       	ldd	r25, Z+7	; 0x07
    1710:	90 93 e5 05 	sts	0x05E5, r25	; 0x8005e5 <pxCurrentTCB+0x1>
    1714:	80 93 e4 05 	sts	0x05E4, r24	; 0x8005e4 <pxCurrentTCB>
    1718:	20 93 93 05 	sts	0x0593, r18	; 0x800593 <uxTopReadyPriority>
    171c:	e0 91 e4 05 	lds	r30, 0x05E4	; 0x8005e4 <pxCurrentTCB>
    1720:	f0 91 e5 05 	lds	r31, 0x05E5	; 0x8005e5 <pxCurrentTCB+0x1>
    1724:	85 a1       	ldd	r24, Z+37	; 0x25
    1726:	0e 94 b9 01 	call	0x372	; 0x372 <switch_in>
    172a:	08 95       	ret

0000172c <vTaskPlaceOnEventList>:
    172c:	cf 93       	push	r28
    172e:	df 93       	push	r29
    1730:	eb 01       	movw	r28, r22
    1732:	60 91 e4 05 	lds	r22, 0x05E4	; 0x8005e4 <pxCurrentTCB>
    1736:	70 91 e5 05 	lds	r23, 0x05E5	; 0x8005e5 <pxCurrentTCB+0x1>
    173a:	64 5f       	subi	r22, 0xF4	; 244
    173c:	7f 4f       	sbci	r23, 0xFF	; 255
    173e:	0e 94 3e 02 	call	0x47c	; 0x47c <vListInsert>
    1742:	61 e0       	ldi	r22, 0x01	; 1
    1744:	ce 01       	movw	r24, r28
    1746:	0e 94 20 08 	call	0x1040	; 0x1040 <prvAddCurrentTaskToDelayedList>
    174a:	df 91       	pop	r29
    174c:	cf 91       	pop	r28
    174e:	08 95       	ret

00001750 <xTaskRemoveFromEventList>:
    1750:	0f 93       	push	r16
    1752:	1f 93       	push	r17
    1754:	cf 93       	push	r28
    1756:	df 93       	push	r29
    1758:	dc 01       	movw	r26, r24
    175a:	15 96       	adiw	r26, 0x05	; 5
    175c:	ed 91       	ld	r30, X+
    175e:	fc 91       	ld	r31, X
    1760:	16 97       	sbiw	r26, 0x06	; 6
    1762:	c6 81       	ldd	r28, Z+6	; 0x06
    1764:	d7 81       	ldd	r29, Z+7	; 0x07
    1766:	8e 01       	movw	r16, r28
    1768:	04 5f       	subi	r16, 0xF4	; 244
    176a:	1f 4f       	sbci	r17, 0xFF	; 255
    176c:	c8 01       	movw	r24, r16
    176e:	0e 94 6f 02 	call	0x4de	; 0x4de <uxListRemove>
    1772:	80 91 89 05 	lds	r24, 0x0589	; 0x800589 <uxSchedulerSuspended>
    1776:	81 11       	cpse	r24, r1
    1778:	1c c0       	rjmp	.+56     	; 0x17b2 <xTaskRemoveFromEventList+0x62>
    177a:	0a 50       	subi	r16, 0x0A	; 10
    177c:	11 09       	sbc	r17, r1
    177e:	c8 01       	movw	r24, r16
    1780:	0e 94 6f 02 	call	0x4de	; 0x4de <uxListRemove>
    1784:	8e 89       	ldd	r24, Y+22	; 0x16
    1786:	90 91 93 05 	lds	r25, 0x0593	; 0x800593 <uxTopReadyPriority>
    178a:	98 17       	cp	r25, r24
    178c:	10 f4       	brcc	.+4      	; 0x1792 <xTaskRemoveFromEventList+0x42>
    178e:	80 93 93 05 	sts	0x0593, r24	; 0x800593 <uxTopReadyPriority>
    1792:	90 e0       	ldi	r25, 0x00	; 0
    1794:	9c 01       	movw	r18, r24
    1796:	22 0f       	add	r18, r18
    1798:	33 1f       	adc	r19, r19
    179a:	22 0f       	add	r18, r18
    179c:	33 1f       	adc	r19, r19
    179e:	22 0f       	add	r18, r18
    17a0:	33 1f       	adc	r19, r19
    17a2:	82 0f       	add	r24, r18
    17a4:	93 1f       	adc	r25, r19
    17a6:	b8 01       	movw	r22, r16
    17a8:	80 54       	subi	r24, 0x40	; 64
    17aa:	9a 4f       	sbci	r25, 0xFA	; 250
    17ac:	0e 94 1d 02 	call	0x43a	; 0x43a <vListInsertEnd>
    17b0:	05 c0       	rjmp	.+10     	; 0x17bc <xTaskRemoveFromEventList+0x6c>
    17b2:	b8 01       	movw	r22, r16
    17b4:	81 ea       	ldi	r24, 0xA1	; 161
    17b6:	95 e0       	ldi	r25, 0x05	; 5
    17b8:	0e 94 1d 02 	call	0x43a	; 0x43a <vListInsertEnd>
    17bc:	e0 91 e4 05 	lds	r30, 0x05E4	; 0x8005e4 <pxCurrentTCB>
    17c0:	f0 91 e5 05 	lds	r31, 0x05E5	; 0x8005e5 <pxCurrentTCB+0x1>
    17c4:	9e 89       	ldd	r25, Y+22	; 0x16
    17c6:	86 89       	ldd	r24, Z+22	; 0x16
    17c8:	89 17       	cp	r24, r25
    17ca:	20 f4       	brcc	.+8      	; 0x17d4 <xTaskRemoveFromEventList+0x84>
    17cc:	81 e0       	ldi	r24, 0x01	; 1
    17ce:	80 93 90 05 	sts	0x0590, r24	; 0x800590 <xYieldPending>
    17d2:	01 c0       	rjmp	.+2      	; 0x17d6 <xTaskRemoveFromEventList+0x86>
    17d4:	80 e0       	ldi	r24, 0x00	; 0
    17d6:	df 91       	pop	r29
    17d8:	cf 91       	pop	r28
    17da:	1f 91       	pop	r17
    17dc:	0f 91       	pop	r16
    17de:	08 95       	ret

000017e0 <vTaskSetTimeOutState>:
    17e0:	20 91 8f 05 	lds	r18, 0x058F	; 0x80058f <xNumOfOverflows>
    17e4:	fc 01       	movw	r30, r24
    17e6:	20 83       	st	Z, r18
    17e8:	20 91 94 05 	lds	r18, 0x0594	; 0x800594 <xTickCount>
    17ec:	30 91 95 05 	lds	r19, 0x0595	; 0x800595 <xTickCount+0x1>
    17f0:	32 83       	std	Z+2, r19	; 0x02
    17f2:	21 83       	std	Z+1, r18	; 0x01
    17f4:	08 95       	ret

000017f6 <xTaskCheckForTimeOut>:
    17f6:	cf 93       	push	r28
    17f8:	df 93       	push	r29
    17fa:	fc 01       	movw	r30, r24
    17fc:	0f b6       	in	r0, 0x3f	; 63
    17fe:	f8 94       	cli
    1800:	0f 92       	push	r0
    1802:	20 91 94 05 	lds	r18, 0x0594	; 0x800594 <xTickCount>
    1806:	30 91 95 05 	lds	r19, 0x0595	; 0x800595 <xTickCount+0x1>
    180a:	80 91 8f 05 	lds	r24, 0x058F	; 0x80058f <xNumOfOverflows>
    180e:	90 81       	ld	r25, Z
    1810:	98 17       	cp	r25, r24
    1812:	29 f0       	breq	.+10     	; 0x181e <xTaskCheckForTimeOut+0x28>
    1814:	81 81       	ldd	r24, Z+1	; 0x01
    1816:	92 81       	ldd	r25, Z+2	; 0x02
    1818:	28 17       	cp	r18, r24
    181a:	39 07       	cpc	r19, r25
    181c:	b0 f4       	brcc	.+44     	; 0x184a <xTaskCheckForTimeOut+0x54>
    181e:	a1 81       	ldd	r26, Z+1	; 0x01
    1820:	b2 81       	ldd	r27, Z+2	; 0x02
    1822:	eb 01       	movw	r28, r22
    1824:	48 81       	ld	r20, Y
    1826:	59 81       	ldd	r21, Y+1	; 0x01
    1828:	c9 01       	movw	r24, r18
    182a:	8a 1b       	sub	r24, r26
    182c:	9b 0b       	sbc	r25, r27
    182e:	84 17       	cp	r24, r20
    1830:	95 07       	cpc	r25, r21
    1832:	68 f4       	brcc	.+26     	; 0x184e <xTaskCheckForTimeOut+0x58>
    1834:	cf 01       	movw	r24, r30
    1836:	a2 1b       	sub	r26, r18
    1838:	b3 0b       	sbc	r27, r19
    183a:	4a 0f       	add	r20, r26
    183c:	5b 1f       	adc	r21, r27
    183e:	59 83       	std	Y+1, r21	; 0x01
    1840:	48 83       	st	Y, r20
    1842:	0e 94 f0 0b 	call	0x17e0	; 0x17e0 <vTaskSetTimeOutState>
    1846:	80 e0       	ldi	r24, 0x00	; 0
    1848:	03 c0       	rjmp	.+6      	; 0x1850 <xTaskCheckForTimeOut+0x5a>
    184a:	81 e0       	ldi	r24, 0x01	; 1
    184c:	01 c0       	rjmp	.+2      	; 0x1850 <xTaskCheckForTimeOut+0x5a>
    184e:	81 e0       	ldi	r24, 0x01	; 1
    1850:	0f 90       	pop	r0
    1852:	0f be       	out	0x3f, r0	; 63
    1854:	df 91       	pop	r29
    1856:	cf 91       	pop	r28
    1858:	08 95       	ret

0000185a <vTaskMissedYield>:
    185a:	81 e0       	ldi	r24, 0x01	; 1
    185c:	80 93 90 05 	sts	0x0590, r24	; 0x800590 <xYieldPending>
    1860:	08 95       	ret

00001862 <xTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
    1862:	0f 93       	push	r16
    1864:	1f 93       	push	r17
    1866:	cf 93       	push	r28
    1868:	df 93       	push	r29
    186a:	fc 01       	movw	r30, r24
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
	BaseType_t xReturn = pdFALSE;

		if( pxMutexHolder != NULL )
    186c:	89 2b       	or	r24, r25
    186e:	79 f1       	breq	.+94     	; 0x18ce <xTaskPriorityDisinherit+0x6c>
			interrupt, and if a mutex is given by the holding task then it must
			be the running state task. */
			configASSERT( pxTCB == pxCurrentTCB );

			configASSERT( pxTCB->uxMutexesHeld );
			( pxTCB->uxMutexesHeld )--;
    1870:	84 a1       	ldd	r24, Z+36	; 0x24
    1872:	81 50       	subi	r24, 0x01	; 1
    1874:	84 a3       	std	Z+36, r24	; 0x24

			/* Has the holder of the mutex inherited the priority of another
			task? */
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    1876:	26 89       	ldd	r18, Z+22	; 0x16
    1878:	93 a1       	ldd	r25, Z+35	; 0x23
    187a:	29 17       	cp	r18, r25
    187c:	51 f1       	breq	.+84     	; 0x18d2 <xTaskPriorityDisinherit+0x70>
			{
				/* Only disinherit if no other mutexes are held. */
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
    187e:	81 11       	cpse	r24, r1
    1880:	2a c0       	rjmp	.+84     	; 0x18d6 <xTaskPriorityDisinherit+0x74>
    1882:	ef 01       	movw	r28, r30
					/* A task can only have an inherited priority if it holds
					the mutex.  If the mutex is held by a task then it cannot be
					given from an interrupt, and if a mutex is given by the
					holding	task then it must be the running state task.  Remove
					the	holding task from the ready	list. */
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    1884:	8f 01       	movw	r16, r30
    1886:	0e 5f       	subi	r16, 0xFE	; 254
    1888:	1f 4f       	sbci	r17, 0xFF	; 255
    188a:	c8 01       	movw	r24, r16
    188c:	0e 94 6f 02 	call	0x4de	; 0x4de <uxListRemove>
					}

					/* Disinherit the priority before adding the task into the
					new	ready list. */
					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
					pxTCB->uxPriority = pxTCB->uxBasePriority;
    1890:	8b a1       	ldd	r24, Y+35	; 0x23
    1892:	8e 8b       	std	Y+22, r24	; 0x16

					/* Reset the event list item value.  It cannot be in use for
					any other purpose if this task is running, and it must be
					running to give back the mutex. */
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1894:	24 e0       	ldi	r18, 0x04	; 4
    1896:	30 e0       	ldi	r19, 0x00	; 0
    1898:	28 1b       	sub	r18, r24
    189a:	31 09       	sbc	r19, r1
    189c:	3d 87       	std	Y+13, r19	; 0x0d
    189e:	2c 87       	std	Y+12, r18	; 0x0c
					prvAddTaskToReadyList( pxTCB );
    18a0:	90 91 93 05 	lds	r25, 0x0593	; 0x800593 <uxTopReadyPriority>
    18a4:	98 17       	cp	r25, r24
    18a6:	10 f4       	brcc	.+4      	; 0x18ac <xTaskPriorityDisinherit+0x4a>
    18a8:	80 93 93 05 	sts	0x0593, r24	; 0x800593 <uxTopReadyPriority>
    18ac:	90 e0       	ldi	r25, 0x00	; 0
    18ae:	9c 01       	movw	r18, r24
    18b0:	22 0f       	add	r18, r18
    18b2:	33 1f       	adc	r19, r19
    18b4:	22 0f       	add	r18, r18
    18b6:	33 1f       	adc	r19, r19
    18b8:	22 0f       	add	r18, r18
    18ba:	33 1f       	adc	r19, r19
    18bc:	82 0f       	add	r24, r18
    18be:	93 1f       	adc	r25, r19
    18c0:	b8 01       	movw	r22, r16
    18c2:	80 54       	subi	r24, 0x40	; 64
    18c4:	9a 4f       	sbci	r25, 0xFA	; 250
    18c6:	0e 94 1d 02 	call	0x43a	; 0x43a <vListInsertEnd>
					in an order different to that in which they were taken.
					If a context switch did not occur when the first mutex was
					returned, even if a task was waiting on it, then a context
					switch should occur when the last mutex is returned whether
					a task is waiting on it or not. */
					xReturn = pdTRUE;
    18ca:	81 e0       	ldi	r24, 0x01	; 1
    18cc:	05 c0       	rjmp	.+10     	; 0x18d8 <xTaskPriorityDisinherit+0x76>
#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
	BaseType_t xReturn = pdFALSE;
    18ce:	80 e0       	ldi	r24, 0x00	; 0
    18d0:	03 c0       	rjmp	.+6      	; 0x18d8 <xTaskPriorityDisinherit+0x76>
    18d2:	80 e0       	ldi	r24, 0x00	; 0
    18d4:	01 c0       	rjmp	.+2      	; 0x18d8 <xTaskPriorityDisinherit+0x76>
    18d6:	80 e0       	ldi	r24, 0x00	; 0
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
	}
    18d8:	df 91       	pop	r29
    18da:	cf 91       	pop	r28
    18dc:	1f 91       	pop	r17
    18de:	0f 91       	pop	r16
    18e0:	08 95       	ret

000018e2 <__udivmodsi4>:
    18e2:	a1 e2       	ldi	r26, 0x21	; 33
    18e4:	1a 2e       	mov	r1, r26
    18e6:	aa 1b       	sub	r26, r26
    18e8:	bb 1b       	sub	r27, r27
    18ea:	fd 01       	movw	r30, r26
    18ec:	0d c0       	rjmp	.+26     	; 0x1908 <__udivmodsi4_ep>

000018ee <__udivmodsi4_loop>:
    18ee:	aa 1f       	adc	r26, r26
    18f0:	bb 1f       	adc	r27, r27
    18f2:	ee 1f       	adc	r30, r30
    18f4:	ff 1f       	adc	r31, r31
    18f6:	a2 17       	cp	r26, r18
    18f8:	b3 07       	cpc	r27, r19
    18fa:	e4 07       	cpc	r30, r20
    18fc:	f5 07       	cpc	r31, r21
    18fe:	20 f0       	brcs	.+8      	; 0x1908 <__udivmodsi4_ep>
    1900:	a2 1b       	sub	r26, r18
    1902:	b3 0b       	sbc	r27, r19
    1904:	e4 0b       	sbc	r30, r20
    1906:	f5 0b       	sbc	r31, r21

00001908 <__udivmodsi4_ep>:
    1908:	66 1f       	adc	r22, r22
    190a:	77 1f       	adc	r23, r23
    190c:	88 1f       	adc	r24, r24
    190e:	99 1f       	adc	r25, r25
    1910:	1a 94       	dec	r1
    1912:	69 f7       	brne	.-38     	; 0x18ee <__udivmodsi4_loop>
    1914:	60 95       	com	r22
    1916:	70 95       	com	r23
    1918:	80 95       	com	r24
    191a:	90 95       	com	r25
    191c:	9b 01       	movw	r18, r22
    191e:	ac 01       	movw	r20, r24
    1920:	bd 01       	movw	r22, r26
    1922:	cf 01       	movw	r24, r30
    1924:	08 95       	ret

00001926 <malloc>:
    1926:	0f 93       	push	r16
    1928:	1f 93       	push	r17
    192a:	cf 93       	push	r28
    192c:	df 93       	push	r29
    192e:	82 30       	cpi	r24, 0x02	; 2
    1930:	91 05       	cpc	r25, r1
    1932:	10 f4       	brcc	.+4      	; 0x1938 <malloc+0x12>
    1934:	82 e0       	ldi	r24, 0x02	; 2
    1936:	90 e0       	ldi	r25, 0x00	; 0
    1938:	e0 91 e8 05 	lds	r30, 0x05E8	; 0x8005e8 <__flp>
    193c:	f0 91 e9 05 	lds	r31, 0x05E9	; 0x8005e9 <__flp+0x1>
    1940:	20 e0       	ldi	r18, 0x00	; 0
    1942:	30 e0       	ldi	r19, 0x00	; 0
    1944:	a0 e0       	ldi	r26, 0x00	; 0
    1946:	b0 e0       	ldi	r27, 0x00	; 0
    1948:	30 97       	sbiw	r30, 0x00	; 0
    194a:	19 f1       	breq	.+70     	; 0x1992 <malloc+0x6c>
    194c:	40 81       	ld	r20, Z
    194e:	51 81       	ldd	r21, Z+1	; 0x01
    1950:	02 81       	ldd	r16, Z+2	; 0x02
    1952:	13 81       	ldd	r17, Z+3	; 0x03
    1954:	48 17       	cp	r20, r24
    1956:	59 07       	cpc	r21, r25
    1958:	c8 f0       	brcs	.+50     	; 0x198c <malloc+0x66>
    195a:	84 17       	cp	r24, r20
    195c:	95 07       	cpc	r25, r21
    195e:	69 f4       	brne	.+26     	; 0x197a <malloc+0x54>
    1960:	10 97       	sbiw	r26, 0x00	; 0
    1962:	31 f0       	breq	.+12     	; 0x1970 <malloc+0x4a>
    1964:	12 96       	adiw	r26, 0x02	; 2
    1966:	0c 93       	st	X, r16
    1968:	12 97       	sbiw	r26, 0x02	; 2
    196a:	13 96       	adiw	r26, 0x03	; 3
    196c:	1c 93       	st	X, r17
    196e:	27 c0       	rjmp	.+78     	; 0x19be <malloc+0x98>
    1970:	00 93 e8 05 	sts	0x05E8, r16	; 0x8005e8 <__flp>
    1974:	10 93 e9 05 	sts	0x05E9, r17	; 0x8005e9 <__flp+0x1>
    1978:	22 c0       	rjmp	.+68     	; 0x19be <malloc+0x98>
    197a:	21 15       	cp	r18, r1
    197c:	31 05       	cpc	r19, r1
    197e:	19 f0       	breq	.+6      	; 0x1986 <malloc+0x60>
    1980:	42 17       	cp	r20, r18
    1982:	53 07       	cpc	r21, r19
    1984:	18 f4       	brcc	.+6      	; 0x198c <malloc+0x66>
    1986:	9a 01       	movw	r18, r20
    1988:	bd 01       	movw	r22, r26
    198a:	ef 01       	movw	r28, r30
    198c:	df 01       	movw	r26, r30
    198e:	f8 01       	movw	r30, r16
    1990:	db cf       	rjmp	.-74     	; 0x1948 <malloc+0x22>
    1992:	21 15       	cp	r18, r1
    1994:	31 05       	cpc	r19, r1
    1996:	f9 f0       	breq	.+62     	; 0x19d6 <malloc+0xb0>
    1998:	28 1b       	sub	r18, r24
    199a:	39 0b       	sbc	r19, r25
    199c:	24 30       	cpi	r18, 0x04	; 4
    199e:	31 05       	cpc	r19, r1
    19a0:	80 f4       	brcc	.+32     	; 0x19c2 <malloc+0x9c>
    19a2:	8a 81       	ldd	r24, Y+2	; 0x02
    19a4:	9b 81       	ldd	r25, Y+3	; 0x03
    19a6:	61 15       	cp	r22, r1
    19a8:	71 05       	cpc	r23, r1
    19aa:	21 f0       	breq	.+8      	; 0x19b4 <malloc+0x8e>
    19ac:	fb 01       	movw	r30, r22
    19ae:	93 83       	std	Z+3, r25	; 0x03
    19b0:	82 83       	std	Z+2, r24	; 0x02
    19b2:	04 c0       	rjmp	.+8      	; 0x19bc <malloc+0x96>
    19b4:	90 93 e9 05 	sts	0x05E9, r25	; 0x8005e9 <__flp+0x1>
    19b8:	80 93 e8 05 	sts	0x05E8, r24	; 0x8005e8 <__flp>
    19bc:	fe 01       	movw	r30, r28
    19be:	32 96       	adiw	r30, 0x02	; 2
    19c0:	44 c0       	rjmp	.+136    	; 0x1a4a <malloc+0x124>
    19c2:	fe 01       	movw	r30, r28
    19c4:	e2 0f       	add	r30, r18
    19c6:	f3 1f       	adc	r31, r19
    19c8:	81 93       	st	Z+, r24
    19ca:	91 93       	st	Z+, r25
    19cc:	22 50       	subi	r18, 0x02	; 2
    19ce:	31 09       	sbc	r19, r1
    19d0:	39 83       	std	Y+1, r19	; 0x01
    19d2:	28 83       	st	Y, r18
    19d4:	3a c0       	rjmp	.+116    	; 0x1a4a <malloc+0x124>
    19d6:	20 91 e6 05 	lds	r18, 0x05E6	; 0x8005e6 <__brkval>
    19da:	30 91 e7 05 	lds	r19, 0x05E7	; 0x8005e7 <__brkval+0x1>
    19de:	23 2b       	or	r18, r19
    19e0:	41 f4       	brne	.+16     	; 0x19f2 <malloc+0xcc>
    19e2:	20 91 02 01 	lds	r18, 0x0102	; 0x800102 <__malloc_heap_start>
    19e6:	30 91 03 01 	lds	r19, 0x0103	; 0x800103 <__malloc_heap_start+0x1>
    19ea:	30 93 e7 05 	sts	0x05E7, r19	; 0x8005e7 <__brkval+0x1>
    19ee:	20 93 e6 05 	sts	0x05E6, r18	; 0x8005e6 <__brkval>
    19f2:	20 91 00 01 	lds	r18, 0x0100	; 0x800100 <__data_start>
    19f6:	30 91 01 01 	lds	r19, 0x0101	; 0x800101 <__data_start+0x1>
    19fa:	21 15       	cp	r18, r1
    19fc:	31 05       	cpc	r19, r1
    19fe:	41 f4       	brne	.+16     	; 0x1a10 <malloc+0xea>
    1a00:	2d b7       	in	r18, 0x3d	; 61
    1a02:	3e b7       	in	r19, 0x3e	; 62
    1a04:	40 91 04 01 	lds	r20, 0x0104	; 0x800104 <__malloc_margin>
    1a08:	50 91 05 01 	lds	r21, 0x0105	; 0x800105 <__malloc_margin+0x1>
    1a0c:	24 1b       	sub	r18, r20
    1a0e:	35 0b       	sbc	r19, r21
    1a10:	e0 91 e6 05 	lds	r30, 0x05E6	; 0x8005e6 <__brkval>
    1a14:	f0 91 e7 05 	lds	r31, 0x05E7	; 0x8005e7 <__brkval+0x1>
    1a18:	e2 17       	cp	r30, r18
    1a1a:	f3 07       	cpc	r31, r19
    1a1c:	a0 f4       	brcc	.+40     	; 0x1a46 <malloc+0x120>
    1a1e:	2e 1b       	sub	r18, r30
    1a20:	3f 0b       	sbc	r19, r31
    1a22:	28 17       	cp	r18, r24
    1a24:	39 07       	cpc	r19, r25
    1a26:	78 f0       	brcs	.+30     	; 0x1a46 <malloc+0x120>
    1a28:	ac 01       	movw	r20, r24
    1a2a:	4e 5f       	subi	r20, 0xFE	; 254
    1a2c:	5f 4f       	sbci	r21, 0xFF	; 255
    1a2e:	24 17       	cp	r18, r20
    1a30:	35 07       	cpc	r19, r21
    1a32:	48 f0       	brcs	.+18     	; 0x1a46 <malloc+0x120>
    1a34:	4e 0f       	add	r20, r30
    1a36:	5f 1f       	adc	r21, r31
    1a38:	50 93 e7 05 	sts	0x05E7, r21	; 0x8005e7 <__brkval+0x1>
    1a3c:	40 93 e6 05 	sts	0x05E6, r20	; 0x8005e6 <__brkval>
    1a40:	81 93       	st	Z+, r24
    1a42:	91 93       	st	Z+, r25
    1a44:	02 c0       	rjmp	.+4      	; 0x1a4a <malloc+0x124>
    1a46:	e0 e0       	ldi	r30, 0x00	; 0
    1a48:	f0 e0       	ldi	r31, 0x00	; 0
    1a4a:	cf 01       	movw	r24, r30
    1a4c:	df 91       	pop	r29
    1a4e:	cf 91       	pop	r28
    1a50:	1f 91       	pop	r17
    1a52:	0f 91       	pop	r16
    1a54:	08 95       	ret

00001a56 <free>:
    1a56:	cf 93       	push	r28
    1a58:	df 93       	push	r29
    1a5a:	00 97       	sbiw	r24, 0x00	; 0
    1a5c:	09 f4       	brne	.+2      	; 0x1a60 <free+0xa>
    1a5e:	81 c0       	rjmp	.+258    	; 0x1b62 <free+0x10c>
    1a60:	fc 01       	movw	r30, r24
    1a62:	32 97       	sbiw	r30, 0x02	; 2
    1a64:	13 82       	std	Z+3, r1	; 0x03
    1a66:	12 82       	std	Z+2, r1	; 0x02
    1a68:	a0 91 e8 05 	lds	r26, 0x05E8	; 0x8005e8 <__flp>
    1a6c:	b0 91 e9 05 	lds	r27, 0x05E9	; 0x8005e9 <__flp+0x1>
    1a70:	10 97       	sbiw	r26, 0x00	; 0
    1a72:	81 f4       	brne	.+32     	; 0x1a94 <free+0x3e>
    1a74:	20 81       	ld	r18, Z
    1a76:	31 81       	ldd	r19, Z+1	; 0x01
    1a78:	82 0f       	add	r24, r18
    1a7a:	93 1f       	adc	r25, r19
    1a7c:	20 91 e6 05 	lds	r18, 0x05E6	; 0x8005e6 <__brkval>
    1a80:	30 91 e7 05 	lds	r19, 0x05E7	; 0x8005e7 <__brkval+0x1>
    1a84:	28 17       	cp	r18, r24
    1a86:	39 07       	cpc	r19, r25
    1a88:	51 f5       	brne	.+84     	; 0x1ade <free+0x88>
    1a8a:	f0 93 e7 05 	sts	0x05E7, r31	; 0x8005e7 <__brkval+0x1>
    1a8e:	e0 93 e6 05 	sts	0x05E6, r30	; 0x8005e6 <__brkval>
    1a92:	67 c0       	rjmp	.+206    	; 0x1b62 <free+0x10c>
    1a94:	ed 01       	movw	r28, r26
    1a96:	20 e0       	ldi	r18, 0x00	; 0
    1a98:	30 e0       	ldi	r19, 0x00	; 0
    1a9a:	ce 17       	cp	r28, r30
    1a9c:	df 07       	cpc	r29, r31
    1a9e:	40 f4       	brcc	.+16     	; 0x1ab0 <free+0x5a>
    1aa0:	4a 81       	ldd	r20, Y+2	; 0x02
    1aa2:	5b 81       	ldd	r21, Y+3	; 0x03
    1aa4:	9e 01       	movw	r18, r28
    1aa6:	41 15       	cp	r20, r1
    1aa8:	51 05       	cpc	r21, r1
    1aaa:	f1 f0       	breq	.+60     	; 0x1ae8 <free+0x92>
    1aac:	ea 01       	movw	r28, r20
    1aae:	f5 cf       	rjmp	.-22     	; 0x1a9a <free+0x44>
    1ab0:	d3 83       	std	Z+3, r29	; 0x03
    1ab2:	c2 83       	std	Z+2, r28	; 0x02
    1ab4:	40 81       	ld	r20, Z
    1ab6:	51 81       	ldd	r21, Z+1	; 0x01
    1ab8:	84 0f       	add	r24, r20
    1aba:	95 1f       	adc	r25, r21
    1abc:	c8 17       	cp	r28, r24
    1abe:	d9 07       	cpc	r29, r25
    1ac0:	59 f4       	brne	.+22     	; 0x1ad8 <free+0x82>
    1ac2:	88 81       	ld	r24, Y
    1ac4:	99 81       	ldd	r25, Y+1	; 0x01
    1ac6:	84 0f       	add	r24, r20
    1ac8:	95 1f       	adc	r25, r21
    1aca:	02 96       	adiw	r24, 0x02	; 2
    1acc:	91 83       	std	Z+1, r25	; 0x01
    1ace:	80 83       	st	Z, r24
    1ad0:	8a 81       	ldd	r24, Y+2	; 0x02
    1ad2:	9b 81       	ldd	r25, Y+3	; 0x03
    1ad4:	93 83       	std	Z+3, r25	; 0x03
    1ad6:	82 83       	std	Z+2, r24	; 0x02
    1ad8:	21 15       	cp	r18, r1
    1ada:	31 05       	cpc	r19, r1
    1adc:	29 f4       	brne	.+10     	; 0x1ae8 <free+0x92>
    1ade:	f0 93 e9 05 	sts	0x05E9, r31	; 0x8005e9 <__flp+0x1>
    1ae2:	e0 93 e8 05 	sts	0x05E8, r30	; 0x8005e8 <__flp>
    1ae6:	3d c0       	rjmp	.+122    	; 0x1b62 <free+0x10c>
    1ae8:	e9 01       	movw	r28, r18
    1aea:	fb 83       	std	Y+3, r31	; 0x03
    1aec:	ea 83       	std	Y+2, r30	; 0x02
    1aee:	49 91       	ld	r20, Y+
    1af0:	59 91       	ld	r21, Y+
    1af2:	c4 0f       	add	r28, r20
    1af4:	d5 1f       	adc	r29, r21
    1af6:	ec 17       	cp	r30, r28
    1af8:	fd 07       	cpc	r31, r29
    1afa:	61 f4       	brne	.+24     	; 0x1b14 <free+0xbe>
    1afc:	80 81       	ld	r24, Z
    1afe:	91 81       	ldd	r25, Z+1	; 0x01
    1b00:	84 0f       	add	r24, r20
    1b02:	95 1f       	adc	r25, r21
    1b04:	02 96       	adiw	r24, 0x02	; 2
    1b06:	e9 01       	movw	r28, r18
    1b08:	99 83       	std	Y+1, r25	; 0x01
    1b0a:	88 83       	st	Y, r24
    1b0c:	82 81       	ldd	r24, Z+2	; 0x02
    1b0e:	93 81       	ldd	r25, Z+3	; 0x03
    1b10:	9b 83       	std	Y+3, r25	; 0x03
    1b12:	8a 83       	std	Y+2, r24	; 0x02
    1b14:	e0 e0       	ldi	r30, 0x00	; 0
    1b16:	f0 e0       	ldi	r31, 0x00	; 0
    1b18:	12 96       	adiw	r26, 0x02	; 2
    1b1a:	8d 91       	ld	r24, X+
    1b1c:	9c 91       	ld	r25, X
    1b1e:	13 97       	sbiw	r26, 0x03	; 3
    1b20:	00 97       	sbiw	r24, 0x00	; 0
    1b22:	19 f0       	breq	.+6      	; 0x1b2a <free+0xd4>
    1b24:	fd 01       	movw	r30, r26
    1b26:	dc 01       	movw	r26, r24
    1b28:	f7 cf       	rjmp	.-18     	; 0x1b18 <free+0xc2>
    1b2a:	8d 91       	ld	r24, X+
    1b2c:	9c 91       	ld	r25, X
    1b2e:	11 97       	sbiw	r26, 0x01	; 1
    1b30:	9d 01       	movw	r18, r26
    1b32:	2e 5f       	subi	r18, 0xFE	; 254
    1b34:	3f 4f       	sbci	r19, 0xFF	; 255
    1b36:	82 0f       	add	r24, r18
    1b38:	93 1f       	adc	r25, r19
    1b3a:	20 91 e6 05 	lds	r18, 0x05E6	; 0x8005e6 <__brkval>
    1b3e:	30 91 e7 05 	lds	r19, 0x05E7	; 0x8005e7 <__brkval+0x1>
    1b42:	28 17       	cp	r18, r24
    1b44:	39 07       	cpc	r19, r25
    1b46:	69 f4       	brne	.+26     	; 0x1b62 <free+0x10c>
    1b48:	30 97       	sbiw	r30, 0x00	; 0
    1b4a:	29 f4       	brne	.+10     	; 0x1b56 <free+0x100>
    1b4c:	10 92 e9 05 	sts	0x05E9, r1	; 0x8005e9 <__flp+0x1>
    1b50:	10 92 e8 05 	sts	0x05E8, r1	; 0x8005e8 <__flp>
    1b54:	02 c0       	rjmp	.+4      	; 0x1b5a <free+0x104>
    1b56:	13 82       	std	Z+3, r1	; 0x03
    1b58:	12 82       	std	Z+2, r1	; 0x02
    1b5a:	b0 93 e7 05 	sts	0x05E7, r27	; 0x8005e7 <__brkval+0x1>
    1b5e:	a0 93 e6 05 	sts	0x05E6, r26	; 0x8005e6 <__brkval>
    1b62:	df 91       	pop	r29
    1b64:	cf 91       	pop	r28
    1b66:	08 95       	ret

00001b68 <memcpy>:
    1b68:	fb 01       	movw	r30, r22
    1b6a:	dc 01       	movw	r26, r24
    1b6c:	02 c0       	rjmp	.+4      	; 0x1b72 <memcpy+0xa>
    1b6e:	01 90       	ld	r0, Z+
    1b70:	0d 92       	st	X+, r0
    1b72:	41 50       	subi	r20, 0x01	; 1
    1b74:	50 40       	sbci	r21, 0x00	; 0
    1b76:	d8 f7       	brcc	.-10     	; 0x1b6e <memcpy+0x6>
    1b78:	08 95       	ret

00001b7a <memset>:
    1b7a:	dc 01       	movw	r26, r24
    1b7c:	01 c0       	rjmp	.+2      	; 0x1b80 <memset+0x6>
    1b7e:	6d 93       	st	X+, r22
    1b80:	41 50       	subi	r20, 0x01	; 1
    1b82:	50 40       	sbci	r21, 0x00	; 0
    1b84:	e0 f7       	brcc	.-8      	; 0x1b7e <memset+0x4>
    1b86:	08 95       	ret

00001b88 <_exit>:
    1b88:	f8 94       	cli

00001b8a <__stop_program>:
    1b8a:	ff cf       	rjmp	.-2      	; 0x1b8a <__stop_program>
